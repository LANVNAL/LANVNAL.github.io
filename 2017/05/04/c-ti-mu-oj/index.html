<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="C++题目（OJ）, LANVNAL&#39;S Blog">
    <meta name="description" content="WEB安全、渗透测试、代码审计、20届毕业本科生">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C++题目（OJ） | LANVNAL&#39;S Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">LANVNAL&#39;S Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/CTF/" class="waves-effect waves-light">
      
      <i class="fas fa-flag" style="zoom: 0.6;"></i>
      
      <span>CTF</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/websec/" class="waves-effect waves-light">
      
      <i class="fab fa-internet-explorer" style="zoom: 0.6;"></i>
      
      <span>Web安全</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" class="waves-effect waves-light">
      
      <i class="fas fa-code" style="zoom: 0.6;"></i>
      
      <span>代码审计</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/%E9%9D%B6%E6%9C%BA/" class="waves-effect waves-light">
      
      <i class="fas fa-server" style="zoom: 0.6;"></i>
      
      <span>靶机</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories/other/" class="waves-effect waves-light">
      
      <i class="fas fa-align-left" style="zoom: 0.6;"></i>
      
      <span>Others</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>网站导航</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="/tags">
          
          <i class="fas fa-tags" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Tags</span>
        </a>
      </li>
      
      <li>
        <a href="/about">
          
          <i class="fas fa-user-circle" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>About</span>
        </a>
      </li>
      
      <li>
        <a href="/friends">
          
          <i class="fas fa-address-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Friends</span>
        </a>
      </li>
      
      <li>
        <a href="/categories">
          
          <i class="fas fa-bookmark" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Categories</span>
        </a>
      </li>
      
      <li>
        <a href="/archives">
          
          <i class="fas fa-archive" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Archives</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">LANVNAL&#39;S Blog</div>
        <div class="logo-desc">
            
            WEB安全、渗透测试、代码审计、20届毕业本科生
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/categories/CTF/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-flag"></i>
			
			CTF
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/websec/" class="waves-effect waves-light">
			
			    <i class="fa-fw fab fa-internet-explorer"></i>
			
			Web安全
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-code"></i>
			
			代码审计
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/%E9%9D%B6%E6%9C%BA/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-server"></i>
			
			靶机
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories/other/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-align-left"></i>
			
			Others
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			网站导航
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a href="/tags " style="margin-left:75px">
				  
				   <i class="fa fas fa-tags" style="position: absolute;left:50px" ></i>
			      
		          <span>Tags</span>
                  </a>
                </li>
              
                <li>

                  <a href="/about " style="margin-left:75px">
				  
				   <i class="fa fas fa-user-circle" style="position: absolute;left:50px" ></i>
			      
		          <span>About</span>
                  </a>
                </li>
              
                <li>

                  <a href="/friends " style="margin-left:75px">
				  
				   <i class="fa fas fa-address-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Friends</span>
                  </a>
                </li>
              
                <li>

                  <a href="/categories " style="margin-left:75px">
				  
				   <i class="fa fas fa-bookmark" style="position: absolute;left:50px" ></i>
			      
		          <span>Categories</span>
                  </a>
                </li>
              
                <li>

                  <a href="/archives " style="margin-left:75px">
				  
				   <i class="fa fas fa-archive" style="position: absolute;left:50px" ></i>
			      
		          <span>Archives</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://lanvnal-blog.oss-cn-qingdao.aliyuncs.com/blog-theme-pic/coverimgs/4.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C++题目（OJ）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/other/">
                                <span class="chip bg-color">other</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/other/" class="post-category">
                                other
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2017-05-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-02-18
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    37.1k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="1-数组类（1）"><a href="#1-数组类（1）" class="headerlink" title="1.数组类（1）"></a>1.数组类（1）</h3><blockquote>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>封装一个整型数组类，用于存储整数和处理的相关功能，支持以下操作：</p>
<ol>
<li>Array::Array()无参构造方法：创建一个空数组对象。</li>
<li>Array::size()方法：返回Array对象中元素个数。</li>
<li>Array::get(int n)方法：按格式从输入读取n元素。</li>
<li>下标运算符：返回下标所指的元素。</li>
</ol>
<p>-—————————————————————————-</p>
<p>你设计一个数组类Array，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的每行以一个整数k开头，表示后面有k个整数。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>把输入的数组，输出出来。每行数据对应一个输出。格式见sample。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 </p>
<p>2 10 20 </p>
<p>1 0</p>
<p> 0</p>
<p> 3 1 2 3</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>10 20</p>
<p> 0 </p>
<p>1 2 3</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code"><a href="#Append-Code" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1572&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
class Array&#123;
private:
    vector&lt;int&gt; arr;
    int l;
public:
    Array()&#123;l=0;&#125;
    int size()&#123;return arr.size();&#125;
    void get(int n)&#123;
        arr.resize(n);
        l=n;
        for(int i=0;i&lt;l;i++)&#123;
            int m;
            cin &gt;&gt; m;
            arr[i]=m;
        &#125;
    &#125;
    int operator[](int n)&#123;return arr[n];&#125;
&#125;;
/////////////////////////////////////
int main()
&#123;
    int cases;
    Array arr;
    cin &gt;&gt; cases;
    for(int ca = 1; ca &lt;= cases; ca++)
    &#123;
        int len;
        cin &gt;&gt; len;
        arr.get(len);
        for(int i = 0; i &lt; arr.size(); i++)
            if(i + 1 == arr.size())
                cout &lt;&lt; arr[i];
            else
                cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    &#125;
&#125;</code></pre>
<blockquote>
<p>详细的函数实现功能：其中vector<int> c.</p>
<p>​                             c.clear()         移除容器中所有数据。</p>
<p>​                             c.empty()         判断容器是否为空。</p>
<p>​                             c.erase(pos)        删除pos位置的数据</p>
<p>​                             c.erase(beg,end) 删除[beg,end)区间的数据</p>
<p>​                             c.front()         传回第一个数据。</p>
<p>​                             c.insert(pos,elem)  在pos位置插入一个elem拷贝</p>
<p>​                             c.pop_back()     删除最后一个数据。</p>
<p>​                             c.push_back(elem) 在尾部加入一个数据。</p>
<p>​                             c.resize(num)     重新设置该容器的大小</p>
<p>​                             c.size()         回容器中实际数据的个数。</p>
<p>​                             c.begin()           返回指向容器第一个元素的迭代器</p>
<p>​                             c.end()             返回指向容器最后一个元素的迭代器</p>
</blockquote>
<p><a href="http://blog.csdn.net/hancunai0017/article/details/7032383" target="_blank" rel="noopener">vector用法</a></p>
<h3 id="2-Base与Derived"><a href="#2-Base与Derived" class="headerlink" title="2.Base与Derived"></a>2.Base与Derived</h3><blockquote>
<h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>定义Base和Derived类，Derived类是Base类的子类，两个类都只有1个int类型的属性。定义它们的构造函数和析构函数，输出信息如样例所示。</p>
<h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入2个整数。</p>
<h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>见样例。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>100</p>
<p>200</p>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Base 100 is created.</p>
<p>Base 100 is created.</p>
<p>Derived 200 is created.</p>
<p>Derived 200 is created.</p>
<p>Base 100 is created.</p>
<p>Base 100 is created.</p>
<h2 id="HINT-1"><a href="#HINT-1" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-1"><a href="#Append-Code-1" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=2074&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Base&#123;
public:
    int a;
    Base(int aa):a(aa)&#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; a &lt;&lt; &quot; is created.&quot; &lt;&lt; endl;&#125;
    ~Base()&#123;cout &lt;&lt; &quot;Base &quot; &lt;&lt; a &lt;&lt; &quot; is created.&quot; &lt;&lt; endl;&#125;
&#125;;
class Derived: public Base&#123;
public:
    int b;
    Derived(int aa,int bb):Base(aa),b(bb)&#123;cout &lt;&lt; &quot;Derived &quot; &lt;&lt; a &lt;&lt; &quot; is created.&quot; &lt;&lt; endl;&#125;
    ~Derived()&#123;cout &lt;&lt; &quot;Derived &quot; &lt;&lt; a &lt;&lt; &quot; is created.&quot; &lt;&lt; endl;&#125;
&#125;;
int main()
&#123;
    int a, b;
    cin&gt;&gt;a&gt;&gt;b;
    Base base(a);
    Derived derived(a, b);
    return 0;
&#125;</code></pre>
<h3 id="3-编写函数：三个数的最大最小值-Append-Code"><a href="#3-编写函数：三个数的最大最小值-Append-Code" class="headerlink" title="3.编写函数：三个数的最大最小值 (Append Code)"></a>3.编写函数：三个数的最大最小值 (Append Code)</h3><blockquote>
<h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>给出三个数a,b,c，最大值是？最小值是？</p>
<p>-—————————————————————————-</p>
<p>编写以下两个函数：</p>
<p>get_num()的功能是读取输入的三个整数a,b,c；</p>
<p>max_min()的功能是求出a,b,c的最大值和最小值。</p>
<p>以上函数的调用格式见“Append Code”。这里不给出函数原型，请通过main()函数自行确定。</p>
<h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：a,b,c。a,b,c都在int类型范围内。</p>
<h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应输出一行：为a,b,c的最大值和最小值，格式见sample。</p>
<h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5</p>
<p>20 15 10</p>
<p>10 15 20</p>
<p>100 100 0</p>
<p>0 1 -1</p>
<p>0 0 0</p>
<h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>case 1 : 20, 10</p>
<p>case 2 : 20, 10</p>
<p>case 3 : 100, 0</p>
<p>case 4 : 1, -1</p>
<p>case 5 : 0, 0</p>
<h2 id="HINT-2"><a href="#HINT-2" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-2"><a href="#Append-Code-2" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=0&pid=1382&getkey=" target="_blank" rel="noopener">append.c</a>, <a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1382&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
void get_num(int &amp;a,int &amp;b,int &amp;c)&#123;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
&#125;
void max_min(int &amp;mmax,int &amp;mmin,int &amp;a,int &amp;b,int &amp;c)&#123;
    mmax = a;
    mmin = a;
    if(b &gt; mmax)
        mmax = b;  
    if(b &lt; mmin)
        mmin = b;
    if(c &gt; mmax)
        mmax = c;
    if(c &lt; mmin)
        mmin = c;
&#125;
////////////////////////////
int main()
&#123;
    int cases;
    int mmax, mmin, a, b, c;

    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        get_num(a, b, c);
        max_min(mmax, mmin, a, b, c);
        cout&lt;&lt;&quot;case &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;mmax&lt;&lt;&quot;, &quot;&lt;&lt;mmin&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<h3 id="4-重载函数：max"><a href="#4-重载函数：max" class="headerlink" title="4.重载函数：max"></a>4.重载函数：max</h3><blockquote>
<h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><p>编写两个名为max的函数，它们是重载函数 ，用于求两个整数或实数的最大值。它们的原型分别是：</p>
<p>int max(int a,int b);</p>
<p>double max(double a,double b);</p>
<p>返回值是a和b的最大值。</p>
<h2 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h2><p>输入4个数，前两个数是int类型的整数，后2个数是double类型的实数。</p>
<h2 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h2><p>输出2个数，每个数占一行。第一个数对应于输入的两个整数的最大值，第二个数对应于输入的两个实数的最大值。</p>
<h2 id="Sample-Input-3"><a href="#Sample-Input-3" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 2</p>
<p>1.4 1.3</p>
<h2 id="Sample-Output-3"><a href="#Sample-Output-3" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>21.4</p>
<h2 id="HINT-3"><a href="#HINT-3" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-3"><a href="#Append-Code-3" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1279&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int max(int a,int b)&#123;
    int max;
    if(a &gt; b)
        max = a;
    else
        max = b;
    return max;
&#125;
double max(double a,double b)&#123;
    double max;
    if(a &gt; b)
        max = a;
    else
        max = b;
    return max;
&#125;
////////////////////
int main()
&#123;
    int a,b;
    double c,d;
    cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;max(a,b)&lt;&lt;endl;
    cin&gt;&gt;c&gt;&gt;d;
    cout&lt;&lt;max(c,d)&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<h3 id="5-默认参数：求圆面积"><a href="#5-默认参数：求圆面积" class="headerlink" title="5.默认参数：求圆面积"></a>5.默认参数：求圆面积</h3><blockquote>
<h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>编写一个带默认值的函数，用于求圆面积。其原型为：</p>
<p>double area(double r=1.0);</p>
<p>当调用函数时指定参数r，则求半径为r的圆的面积；否则求半径为1的圆面积。</p>
<p>其中，PI取值3.14。</p>
<h2 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h2><p>一个实数，是圆的半径。</p>
<h2 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h2><p>输出有2行。第一行是以输入数值为半径的圆面积，第二行是半径为1的圆面积。</p>
<h2 id="Sample-Input-4"><a href="#Sample-Input-4" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>19</p>
<h2 id="Sample-Output-4"><a href="#Sample-Output-4" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1133.54</p>
<p>3.14</p>
<h2 id="HINT-4"><a href="#HINT-4" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-4"><a href="#Append-Code-4" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1280&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
#define PI 3.14
double area(double r = 1.0)&#123;
    return PI*r*r;
&#125; 

/////////////////////////
int main()
&#123;
    double r;
    cin&gt;&gt;r;
    cout&lt;&lt;area(r)&lt;&lt;endl;
    cout&lt;&lt;area()&lt;&lt;endl;
    return 0;
&#125;</code></pre>
<h3 id="6-求-x-y-z-2"><a href="#6-求-x-y-z-2" class="headerlink" title="6.求(x-y+z)*2"></a>6.求(x-y+z)*2</h3><blockquote>
<h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>编写一个程序，求解以下三个函数：</p>
<p>f(x,y,z)=2*(x-y+z)</p>
<p>f(x,y)  =2*(x-y)</p>
<p>f(x)    =2*(x-1)</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-5"><a href="#Input-5" class="headerlink" title="Input"></a>Input</h2><p>输入的测试数据为多组。每组测试数据的第一个数是n（1&lt;=n&lt;=3），表示后面有n个整数。</p>
<p>当n为3时，后跟3个输入为x,y,z；</p>
<p>当n为2时，后跟2个输入为x,y；</p>
<p>当n为1时，后跟1个输入为x；</p>
<p>当n为0时，表示输入结束</p>
<p>输入的n不会有其他取值。</p>
<p>所有运算都不会超出int类型范围。</p>
<h2 id="Output-5"><a href="#Output-5" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一个输出。输出x-y+z的值。</p>
<h2 id="Sample-Input-5"><a href="#Sample-Input-5" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 121 38 452 39 111 73</p>
<h2 id="Sample-Output-5"><a href="#Sample-Output-5" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>25656144</p>
<h2 id="HINT-5"><a href="#HINT-5" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-5"><a href="#Append-Code-5" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1381&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int f(int x,int y,int z)&#123;
    return 2*(x-y+z);
&#125;
int f(int x,int y)&#123;
    return 2*(x-y);
&#125;
int f(int x)&#123;
    return 2*(x-1);
&#125;

////////////////////////
int main()
&#123;
    int n, x, y, z;
    while(cin&gt;&gt;n)
    &#123;
        if(n == 3)
        &#123;
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
            cout&lt;&lt;f(x, y, z)&lt;&lt;endl;
        &#125;
        if(n == 2)
        &#123;
            cin&gt;&gt;x&gt;&gt;y;
            cout&lt;&lt;f(x, y)&lt;&lt;endl;
        &#125;
        if(n == 1)
        &#123;
            cin&gt;&gt;x;
            cout&lt;&lt;f(x)&lt;&lt;endl;
        &#125;
        if(n == 0)
            break;
    &#125;
&#125;</code></pre>
<h3 id="7-编写函数：Swap-I-Append-Code"><a href="#7-编写函数：Swap-I-Append-Code" class="headerlink" title="7.编写函数：Swap (I) (Append Code)"></a>7.编写函数：Swap (I) (Append Code)</h3><blockquote>
<h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>编写用来交换两个数的函数，使得“Append Code”中的main()函数能正确运行。</p>
<p>-—————————————————————————-</p>
<p>用C实现三个函数int_swap()、dbl_swap()、SWAP()，其中SWAP()是个带参宏。</p>
<p>用C++实现两个函数，都以swap()命名。</p>
<p>以上函数的调用格式见“Append Code”。这里不给出函数原型，它们的参数请通过main()函数自行确定。</p>
<h2 id="Input-6"><a href="#Input-6" class="headerlink" title="Input"></a>Input</h2><p>输入为4行，每行2个数。</p>
<h2 id="Output-6"><a href="#Output-6" class="headerlink" title="Output"></a>Output</h2><p>输出为4行，每行2个数。每行输出的两数为每行输入的逆序。</p>
<h2 id="Sample-Input-6"><a href="#Sample-Input-6" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>12 57</p>
<p>9 -3</p>
<p>-12 4</p>
<p>3 5</p>
<h2 id="Sample-Output-6"><a href="#Sample-Output-6" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>57 12-3 94 -125 3</p>
<h2 id="HINT-6"><a href="#HINT-6" class="headerlink" title="HINT"></a>HINT</h2><p>“Append Code”中用到的头文件、全局变量或宏的定义应自行补充。</p>
<h2 id="Append-Code-6"><a href="#Append-Code-6" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=0&pid=1107&getkey=" target="_blank" rel="noopener">append.c</a>, <a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1107&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int swap(int *a,int *b)&#123;
    int c;
    c = *a;
    *a = *b;
    *b = c;
&#125;
double swap(double *a,double *b)&#123;
    double c;
    c = *a;
    *a = *b;
    *b = c;

&#125;
////////////////////
int main()
&#123;
    int x1, y1;

    cin&gt;&gt;x1&gt;&gt;y1;
    swap(&amp;x1, &amp;y1);
    cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;

    cin&gt;&gt;x1&gt;&gt;y1;
    swap(x1, y1);
    cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;y1&lt;&lt;endl;

    double x2, y2;

    cin&gt;&gt;x2&gt;&gt;y2;
    swap(&amp;x2, &amp;y2);
    cout&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;endl;

    cin&gt;&gt;x2&gt;&gt;y2;
    swap(x2, y2);
    cout&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;y2&lt;&lt;endl;
&#125;</code></pre>
<h3 id="8-你会定义类吗？"><a href="#8-你会定义类吗？" class="headerlink" title="8.你会定义类吗？"></a>8.你会定义类吗？</h3><blockquote>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>定义一个类Demo，有构造函数、析构函数和成员函数show()，其中show()根据样例的格式输出具体属性值。该类只有一个int类型的成员。</p>
<h2 id="Input-7"><a href="#Input-7" class="headerlink" title="Input"></a>Input</h2><p>输入只有一个整数，int类型范围内。</p>
<h2 id="Output-7"><a href="#Output-7" class="headerlink" title="Output"></a>Output</h2><p>见样例。</p>
<h2 id="Sample-Input-7"><a href="#Sample-Input-7" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>-100</p>
<h2 id="Sample-Output-7"><a href="#Sample-Output-7" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>A data 10 is created!A data 0 is created!A data -100 is created!This is data 10This is data 0This is data -100A data -100 is erased!A data 0 is erased!A data 10 is erased!</p>
<h2 id="HINT-7"><a href="#HINT-7" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-7"><a href="#Append-Code-7" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="file:///D:/郝佳伟的文件/学习资料/OJ-C++/实验/1/Problem%20A_%20你会定义类吗？_files/Source%20Code.html">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Demo&#123;
public:
    int a;
    Demo(int aa=0):a(aa)&#123;cout &lt;&lt; &quot;A data &quot; &lt;&lt; a &lt;&lt; &quot; is created!&quot; &lt;&lt; endl;&#125;
    ~Demo()&#123;cout &lt;&lt; &quot;A data &quot; &lt;&lt; a &lt;&lt; &quot; is erased!&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;This is data &quot; &lt;&lt; a &lt;&lt; endl;&#125;
&#125;;
/////////////////////
int main()
&#123;
    Demo tmp(10), tmp2;
    int d;
    cin&gt;&gt;d;
    Demo tmp3(d);

    tmp.show();
    tmp2.show();
    tmp3.show();
    return 0;
&#125;
</code></pre>
<h3 id="9-一元二次方程类"><a href="#9-一元二次方程类" class="headerlink" title="9.一元二次方程类"></a>9.一元二次方程类</h3><blockquote>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>定义一个表示一元二次方程的类Equation，该类至少具有以下3个数据成员：a、b和c，用于表示方程“a<em>x</em>x + b*x +c = 0”。同时，该类还至少具有以下两个成员函数：</p>
<p>\1. void solve()：用于求方程的根。</p>
<p>\2. void printRoot()：用于输出方程的根。</p>
<p>设定：</p>
<p>\1. 所有输入的a、b、c所生成的方程必定有个2个不同的实根。</p>
<p>\2. 输出的两个根按照从大到小的顺序输出，两个根之间用一个空格隔开，而且每个根必须且仅能保留2位小数，即使小数部分为0。</p>
<p>\3. 请根据样例和给出的main()函数定义相应的构造函数。</p>
<h2 id="Input-8"><a href="#Input-8" class="headerlink" title="Input"></a>Input</h2><p>输入有若干行，每行有3个实数，分别为方程“a<em>x</em>x + b*x + c = 0”中的系数a、b、c。</p>
<h2 id="Output-8"><a href="#Output-8" class="headerlink" title="Output"></a>Output</h2><p>按照题目要求中的设定条件2输出方程的根。</p>
<h2 id="Sample-Input-8"><a href="#Sample-Input-8" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 3 2</p>
<h2 id="Sample-Output-8"><a href="#Sample-Output-8" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>-1.00 -2.00</p>
<h2 id="HINT-8"><a href="#HINT-8" class="headerlink" title="HINT"></a>HINT</h2><p>可以使用fixed和setprecision()来实现输出固定小数位数的数值。</p>
<h2 id="Append-Code-8"><a href="#Append-Code-8" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="file:///D:/郝佳伟的文件/学习资料/OJ-C++/实验/1/Problem%20B_%20一元二次方程类_files/Source%20Code.html">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;math.h&gt;
using namespace std;
class Equation&#123;
public:
    double a,b,c,drt,x1,x2;
    Equation(double aa,double bb,double cc):a(aa),b(bb),c(cc)&#123;&#125;
    void solve()&#123;
        drt=sqrt(b*b-4*a*c);
    &#125;
    void printRoot()&#123;
        x1=(-b+drt)/(2*a);
        x2=(-b-drt)/(2*a);
         cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; x2 &lt;&lt; endl; 
    &#125;
&#125;;
////////////////////////////////
int main()
&#123;
    double a, b, c;
    while (cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)
    &#123;
        Equation equ(a,b,c);
        equ.solve();
        equ.printRoot();
    &#125;
    return 0;
&#125;</code></pre>
<blockquote>
<h3 id="fixed-和setprecision-的用法"><a href="#fixed-和setprecision-的用法" class="headerlink" title="fixed 和setprecision()的用法"></a>fixed 和setprecision()的用法</h3><p>使用setprecision(n)可控制输出流显示浮点数的数字个数。C++默认的流输出数值有效位是6。<br>  如果setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。setiosflags(ios::fixed)是用定点方式表示实数。<br>  如果与setiosnags(ios::scientific)合用， 可以控制指数表示法的小数位数。setiosflags(ios::scientific)是用指数方式表示实数。</p>
</blockquote>
<h3 id="10-整数的封装"><a href="#10-整数的封装" class="headerlink" title="10.整数的封装"></a>10.整数的封装</h3><blockquote>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>现在，请编写一个Integer类，将整数封装起来。目前，只需要你来实现最基本的功能：</p>
<p>\1. 具有2个构造函数：</p>
<p>（1）Integer::Integer(int)：根据参数构建一个整数对象。</p>
<p>（2）Integer::Integer(char*, int)：根据给定的字符串和进制来构建一个整数对象。</p>
<p>\2. 具有一个int Integer::getValue()方法，用于返回Integer类中所封装的整数的具体数值。</p>
<h2 id="Input-9"><a href="#Input-9" class="headerlink" title="Input"></a>Input</h2><p>输入分为多行。</p>
<p>第一行是一个正整数M，表示其后面的M行为M个整数，每行一个整数。</p>
<p>第M+2行是一个正整数N，表示其后有N行。每行由利用一个空格隔开的2部分组成：前半部分是一个字符串，后半部分是该字符串所使用的进制。</p>
<p>注意：</p>
<p>\1. 所有的输入，均在int类型的表示范围内，且所有的输入均为合法输入。</p>
<p>\2. 利用0<del>9和a</del>z可最大可以表示36进制的数值。</p>
<h2 id="Output-9"><a href="#Output-9" class="headerlink" title="Output"></a>Output</h2><p>输出为M+N行，每行为一个十进制整数，且输出顺序应与输入顺序相同。</p>
<h2 id="Sample-Input-9"><a href="#Sample-Input-9" class="headerlink" title="Sample Input"></a>Sample Input</h2><p> 2999-199940111 21a 16z 36a 16</p>
<h2 id="Sample-Output-9"><a href="#Sample-Output-9" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>999-19997263510</p>
<h2 id="HINT-9"><a href="#HINT-9" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-9"><a href="#Append-Code-9" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="file:///D:/郝佳伟的文件/学习资料/OJ-C++/实验/1/Problem%20C_%20整数的封装_files/Source%20Code.html">append.cc</a>, </p>
</blockquote>
<pre><code></code></pre>
<h3 id="11-平面上的点——Point类-I"><a href="#11-平面上的点——Point类-I" class="headerlink" title="11.平面上的点——Point类 (I)"></a>11.平面上的点——Point类 (I)</h3><blockquote>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类的构造方法和show()方法。</p>
<p>接口描述：<br> Point::show()方法：按输出格式输出Point对象。</p>
<h2 id="Input-10"><a href="#Input-10" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-10"><a href="#Output-10" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一个点，X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-10"><a href="#Sample-Input-10" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,23,32,1</p>
<h2 id="Sample-Output-10"><a href="#Sample-Output-10" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, 2)Point : (3, 3)Point : (2, 1)Point : (0, 0)</p>
<h2 id="HINT-10"><a href="#HINT-10" class="headerlink" title="HINT"></a>HINT</h2><p>注意精度控制，C语言的输入输出被禁用。</p>
<h2 id="Append-Code-10"><a href="#Append-Code-10" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1121&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Point&#123;
public:
    double x,y;
    Point():x(0),y(0)&#123;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123;&#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
//////////////////////
int main()
&#123;
    char c;
    double a, b;
    Point q;
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)
    &#123;
        Point p(a, b);
        p.show();
    &#125;
    q.show();
&#125;</code></pre>
<h3 id="12-平面上的点——Point类-II"><a href="#12-平面上的点——Point类-II" class="headerlink" title="12.平面上的点——Point类 (II)"></a>12.平面上的点——Point类 (II)</h3><blockquote>
<h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类的构造方法和show()方法，输出各Point对象的构造和析构次序。</p>
<p>接口描述：<br> Point::show()方法：按输出格式输出Point对象。</p>
<h2 id="Input-11"><a href="#Input-11" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-11"><a href="#Output-11" class="headerlink" title="Output"></a>Output</h2><p>输出每个Point对象的构造和析构行为。对每个Point对象，调用show()方法输出其值：X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-11"><a href="#Sample-Input-11" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,2</p>
<p>3,3</p>
<p>2,1</p>
<h2 id="Sample-Output-11"><a href="#Sample-Output-11" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (0, 0) is created.Point : (1, 2) is created.Point : (1, 2)Point : (1, 2) is erased.Point : (3, 3) is created.Point : (3, 3)Point : (3, 3) is erased.Point : (2, 1) is created.Point : (2, 1)Point : (2, 1) is erased.Point : (0, 0) is copied.Point : (1, 1) is created.Point : (0, 0)Point : (1, 1)Point : (0, 0)Point : (1, 1) is erased.Point : (0, 0) is erased.Point : (0, 0) is erased.</p>
<h2 id="HINT-11"><a href="#HINT-11" class="headerlink" title="HINT"></a>HINT</h2><p>思考构造函数、拷贝构造函数、析构函数的调用时机。</p>
<h2 id="Append-Code-11"><a href="#Append-Code-11" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1122&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Point&#123;
public:
    double x,y;
    Point():x(0),y(0)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(const Point&amp; p):x(p.x),y(p.y)&#123;cout &lt;&lt; &quot;Point : (0, 0) is copied.&quot; &lt;&lt; endl;&#125;
    Point(double xx):x(xx),y(xx)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Point()&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
//////////////////////////
int main()
&#123;
    char c;
    double a, b;
    Point q;
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)
    &#123;
        Point p(a, b);
        p.show();
    &#125;
    Point q1(q), q2(1);
    q1.show();
    q2.show();
    q.show();
&#125;</code></pre>
<h3 id="13-平面上的点——Point类-III"><a href="#13-平面上的点——Point类-III" class="headerlink" title="13.平面上的点——Point类 (III)"></a>13.平面上的点——Point类 (III)</h3><blockquote>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类的构造方法和show()方法，输出各Point对象的构造和析构次序。实现showPoint()函数。</p>
<p>接口描述：<br> showPoint()函数按输出格式输出Point对象，调用Point::show()方法实现。<br> Point::show()方法：按输出格式输出Point对象。</p>
<h2 id="Input-12"><a href="#Input-12" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-12"><a href="#Output-12" class="headerlink" title="Output"></a>Output</h2><p>输出每个Point对象的构造和析构行为。showPoint()函数用来输出（通过参数传入的）Point对象的值：X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-12"><a href="#Sample-Input-12" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,2</p>
<p>3,3</p>
<p>2,1</p>
<h2 id="Sample-Output-12"><a href="#Sample-Output-12" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (0, 0) is created.</p>
<p>Point : (1, 2) is created.</p>
<p>Point : (1, 2) is copied.</p>
<p>Point : (1, 2)</p>
<p>Point : (1, 2) is erased.</p>
<p>Point : (1, 2) is erased.</p>
<p>Point : (3, 3) is created.</p>
<p>Point : (3, 3) is copied.</p>
<p>Point : (3, 3)</p>
<p>Point : (3, 3) is erased.</p>
<p>Point : (3, 3) is erased.</p>
<p>Point : (2, 1) is created.</p>
<p>Point : (2, 1) is copied.</p>
<p>Point : (2, 1)</p>
<p>Point : (2, 1) is erased.</p>
<p>Point : (2, 1) is erased.</p>
<p>Point : (0, 0) is copied.</p>
<p>Point : (1, 1) is created.</p>
<p>Point : (0, 0) is copied.</p>
<p>Point : (1, 1) is copied.</p>
<p>Point : (0, 0) is copied.</p>
<p>Point : (0, 0)</p>
<p>Point : (1, 1)</p>
<p>Point : (0, 0)</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (1, 1) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (1, 1) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<h2 id="HINT-12"><a href="#HINT-12" class="headerlink" title="HINT"></a>HINT</h2><p>思考构造函数、拷贝构造函数、析构函数的调用时机。</p>
<h2 id="Append-Code-12"><a href="#Append-Code-12" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1123&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Point&#123;
public:
    double x,y;
    Point():x(0),y(0)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(const Point&amp; p):x(p.x),y(p.y)&#123;cout &lt;&lt; &quot;Point : (0, 0) is copied.&quot; &lt;&lt; endl;&#125;
    Point(double xx):x(xx),y(xx)&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Point()&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
void showPoint(Point s)&#123;s.show();&#125;
void showPoint(Point a,Point b,Point c)&#123;a.show();b.show();c.show();&#125;
////////////////////////////////
int main()
&#123;
    char c;
    double a, b;
    Point q;
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)
    &#123;
        Point p(a, b);
        showPoint(p);
    &#125;
    Point q1(q), q2(1);
    showPoint(q1, q2, q);
&#125;</code></pre>
<h3 id="14-平面上的点——Point类-IV"><a href="#14-平面上的点——Point类-IV" class="headerlink" title="14.平面上的点——Point类 (IV)"></a>14.平面上的点——Point类 (IV)</h3><blockquote>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。<br> 根据“append.cc”，完成Point类的构造方法和show()、showCounter()、showSumOfPoint()方法；实现showPoint()函数。<br> 接口描述：<br> showPoint()函数：按输出格式输出Point对象，调用Point::show()方法实现。<br> Point::show()方法：按输出格式输出Point对象。<br> Point::showCounter()方法：按格式输出当前程序中Point对象的计数。<br> Point::showSumOfPoint()方法：按格式输出程序运行至当前存在过的Point对象总数。</p>
<h2 id="Input-13"><a href="#Input-13" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-13"><a href="#Output-13" class="headerlink" title="Output"></a>Output</h2><p>对每个Point对象，调用show()方法输出其值，或者用showPoint()函数来输出（通过参数传入的）Point对象的值：X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。调用用showCounter()方法和showSumOfPoint()输出Point对象的计数统计，输出格式见sample。<br> C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-13"><a href="#Sample-Input-13" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,2</p>
<p>3,3</p>
<p>2,1</p>
<h2 id="Sample-Output-13"><a href="#Sample-Output-13" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, 2)</p>
<p>Current : 2 points.</p>
<p>Point : (3, 3)</p>
<p>Current : 2 points.</p>
<p>Point : (2, 1)</p>
<p>Current : 2 points.</p>
<p>In total : 4 points.</p>
<p>Current : 3 points.</p>
<p>Point : (0, 0)</p>
<p>Point : (1, 1)</p>
<p>Point : (0, 0)</p>
<p>In total : 6 points.</p>
<h2 id="HINT-13"><a href="#HINT-13" class="headerlink" title="HINT"></a>HINT</h2><p>对象计数通过静态成员来实现</p>
<h2 id="Append-Code-13"><a href="#Append-Code-13" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1124&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Point&#123;  
private:  
    double x,y;  
    static int sum,num;  
public:  
    Point():x(0),y(0)&#123;num++;sum++;&#125;  
    Point(double a):x(a),y(1)&#123;num++;sum++;&#125;  
    Point(double a,double b):x(a),y(b)&#123;num++;sum++;&#125;  
    Point(const Point&amp;p)&#123;x=p.x;y=p.y;num++;sum++;&#125;  
    ~Point()&#123;num--;&#125;  
    void show()&#123;cout&lt;&lt;setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt;x&lt;&lt;&quot;, &quot;&lt;&lt;y&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;  
    static void showCounter()&#123;cout&lt;&lt;setprecision(16)&lt;&lt;&quot;Current : &quot;&lt;&lt;num&lt;&lt;&quot; points.&quot;&lt;&lt;endl;&#125;  
    static void showSumOfPoint()&#123;cout&lt;&lt;setprecision(16)&lt;&lt;&quot;In total : &quot;&lt;&lt;sum&lt;&lt;&quot; points.&quot;&lt;&lt;endl;&#125;  
&#125;;  
void showPoint(Point &amp;a,Point &amp;b,Point &amp;c)&#123;a.show();b.show();c.show();&#125;  
int Point::sum=0;  
int Point::num=0;  
////////////////////////////
int main()
&#123;
    char c;
    double a, b;
    Point q;
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)
    &#123;
        Point p(a, b);
        p.show();
        p.showCounter();
    &#125;
    q.showSumOfPoint();
    Point q1(q), q2(1);
    Point::showCounter();
    showPoint(q1, q2, q);
    Point::showSumOfPoint();
&#125;</code></pre>
<h3 id="15-平面上的点——Point类-V"><a href="#15-平面上的点——Point类-V" class="headerlink" title="15.平面上的点——Point类 (V)"></a>15.平面上的点——Point类 (V)</h3><blockquote>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。<br> 根据“append.cc”，完成Point类的构造方法和接口描述中的方法。<br> 接口描述：<br> showPoint()函数：按输出格式输出Point对象。<br> Point::show()方法：按输出格式输出Point对象。<br> Point::showSumOfPoint()方法：按格式输出程序运行至当前存在过的Point对象总数。<br> Point::x()方法：取x坐标。<br> Point::y()方法：取y坐标。<br> Point::x(double)方法：传参数设置x坐标并返回。<br> Point::y(double)方法：传参数设置y坐标并返回。<br> Point::getX()方法：取x坐标。<br> Point::getY()方法：取y坐标。<br> Point::setX()方法：传参数设置x坐标并返回。<br> Point::setY()方法：传参数设置y坐标并返回。<br> Point::setPoint(double,double)方法：设置Point对象的x坐标（第一个参数）和y坐标（第二个参数）并返回本对象</p>
<h2 id="Input-14"><a href="#Input-14" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-14"><a href="#Output-14" class="headerlink" title="Output"></a>Output</h2><p>用ShowPoint()函数来输出（通过参数传入的）Point对象的值或坐标值：X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。<br> 对每个Point对象，调用show()方法输出其值，输出格式与ShowPoint()函数略有不同：“Point[i] :”，i表示这是程序运行过程中第i个被创建的Point对象。<br> 调用showSumOfPoint()输出Point对象的计数统计，输出格式见sample。<br> C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-14"><a href="#Sample-Input-14" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,2</p>
<p>3,3</p>
<p>2,1</p>
<h2 id="Sample-Output-14"><a href="#Sample-Output-14" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, 2)</p>
<p>Point : (3, 3)</p>
<p>Point : (2, 1)</p>
<p>Point : (1, 1)</p>
<p>Point : (4, -3)</p>
<p>==========gorgeous separator==========</p>
<p>Point[1] : (1, 0)</p>
<p>Point[2] : (3, 3)</p>
<p>Point[3] : (0, 0)</p>
<p>Point[4] : (4, -3)</p>
<p>Point[64] : (1, 0)</p>
<p>Point[64] : (1, 0)</p>
<p>==========gorgeous separator==========</p>
<p>In total : 66 points.</p>
<h2 id="HINT-14"><a href="#HINT-14" class="headerlink" title="HINT"></a>HINT</h2><p>传递和返回引用是不构造新对象的。给函数正确的返回值。</p>
<h2 id="Append-Code-14"><a href="#Append-Code-14" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1125&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;  
#include &lt;iomanip&gt;  
using namespace std;  
class Point  
&#123;  
private :  
    double x_,y_;  
    static int total_num;  
    int id;  
public:  
    Point()&#123; x_ = 0;y_ = 0;total_num++; id = total_num; &#125;  
    Point (double xx )  
    &#123;  
        x_ = xx;  
        y_ = xx ;  
         total_num++;  
         id = total_num;  
    &#125;  
    Point(double xx, double yy)  
    &#123;  
        x_ = xx;  
        y_ = yy;  
        total_num++;  
        id = total_num;  
    &#125;  
    Point(const Point &amp; pt)  
    &#123;  
        x_ = pt.x_;  
        y_ = pt.y_;  
        total_num++;  
        id = total_num;  
    &#125;  
    double x() const  
    &#123;  
        return x_;  
    &#125;  
    double y() const  
    &#123;  
        return y_;  
    &#125;  
    double x( double xx)  
    &#123;  
        return ( x_ = xx);  
    &#125;  
    double y(double yy)  
    &#123;  
        return ( y_ = yy);  
    &#125;  
    double getX() const  
    &#123;  
        return x_;  
    &#125;  
    double getY() const  
    &#123;  
        return y_;  
    &#125;  
    double setX(double xx)  
    &#123;  
        return ( x_ = xx);  
    &#125;  
    double setY(double yy)  
    &#123;  
        return (y_ = yy);  
    &#125;  
    Point &amp; setPoint(double xx,double yy)  
    &#123;  
        x_ = xx;  
        y_ = yy;  
        return *this;  
    &#125;  
    void show() const  
    &#123;  
          cout&lt;&lt;setprecision(16)&lt;&lt;&quot;Point[&quot;&lt;&lt;id&lt;&lt;&quot;] : (&quot;&lt;&lt; x_ &lt;&lt; &quot;, &quot; &lt;&lt; y_ &lt;&lt; &quot;)&quot; &lt;&lt;endl;  
       //cout &lt;&lt; &quot;Current : &quot; &lt;&lt;num &lt;&lt; &quot; points.&quot;  &lt;&lt;endl;  
    &#125;  
   static void showSumOfPoint()  
    &#123;  
        cout &lt;&lt; setprecision(16) &lt;&lt;&quot;In total : &quot; &lt;&lt;  total_num &lt;&lt; &quot; points.&quot;&lt;&lt;endl;  
    &#125;  
&#125;;  
int Point::total_num;  
void ShowPoint(Point p)  
&#123;  
    cout&lt;&lt;std::setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt;p.x()&lt;&lt;&quot;, &quot;&lt;&lt;p.y()&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
&#125;  

void ShowPoint(double x, double y)  
&#123;  
    Point p(x, y);  
    cout&lt;&lt;std::setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt;p.x()&lt;&lt;&quot;, &quot;&lt;&lt;p.y()&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
&#125;  

void ShowPoint(Point &amp;p, double x, double y)  
&#123;  
    cout&lt;&lt;std::setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt;p.x(x)&lt;&lt;&quot;, &quot;&lt;&lt;p.x(y)&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
&#125;  

int main()  
&#123;  
    int l(0);  
    char c;  
    double a, b;  
    Point pt[60];  
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)  
    &#123;  
        if(a == b)  
            ShowPoint(pt[l].setPoint(a, b));  
        if(a &gt; b)  
            ShowPoint(a, b);  
        if(a &lt; b)  
            ShowPoint(pt[l], a, b);  
        l++;  
    &#125;  
    Point p(a), q(b);  
    ShowPoint(q);  
    double x(0), y(0);  
    for(int i = 0; i &lt; l; i++)  
        x += pt[i].getX(), y -= pt[i].getY();  
    ShowPoint(pt[l].setX(x), pt[l].setY(y));  
    cout&lt;&lt;&quot;==========gorgeous separator==========&quot;&lt;&lt;endl;  
    for(int i = 0; i &lt;= l; i++)  
        pt[i].show();  
    q.setPoint(q.x() - p.x() + a, q.y() - p.y() + b).show();  
    q.show();  
    cout&lt;&lt;&quot;==========gorgeous separator==========&quot;&lt;&lt;endl;  
    p.showSumOfPoint();  
&#125;  </code></pre>
<h3 id="16-平面上的点——Point类-VI"><a href="#16-平面上的点——Point类-VI" class="headerlink" title="16.平面上的点——Point类 (VI)"></a>16.平面上的点——Point类 (VI)</h3><blockquote>
<h2 id="Description-15"><a href="#Description-15" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定。现在我们封装一个“Point类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类的构造方法和接口描述中的方法和函数。</p>
<p>接口描述：<br> showPoint()函数：按输出格式输出Point对象。<br> Point::show()方法：按输出格式输出Point对象。<br> Point::showSumOfPoint()方法：按格式输出程序运行至当前存在过的Point对象总数。<br> Point::x()方法：取x坐标。<br> Point::y()方法：取y坐标。<br> Point::x(double)方法：传参数设置x坐标并返回。<br> Point::y(double)方法：传参数设置y坐标并返回。<br> Point::setPoint(double,double)方法：设置Point对象的x坐标（第一个参数）和y坐标（第二个参数）并返回本对象。<br> Point::isEqual()方法：判断传入的参数与对象的坐标是否相同，相同返回true。<br> Point::copy()方法：传参数复制给对象。<br> Point::inverse()方法，有两个版本：不传参数则将对象自身的x坐标和y坐标互换；若将Point对象做参数传入，则将传入对象的坐标交换复制给对象自身，不修改参数的值。</p>
<h2 id="Input-15"><a href="#Input-15" class="headerlink" title="Input"></a>Input</h2><p>输入多行，每行为一组坐标“x,y”，表示点的x坐标和y坐标，x和y的值都在double数据范围内。</p>
<h2 id="Output-15"><a href="#Output-15" class="headerlink" title="Output"></a>Output</h2><p>用ShowPoint()函数来输出（通过参数传入的）Point对象的值或坐标值：X坐标在前，Y坐标在后，Y坐标前面多输出一个空格。每个坐标的输出精度为最长16位。<br>对每个Point对象，调用show()方法输出其值，输出格式与ShowPoint()函数略有不同：“Point[i] :”，i表示这是程序运行过程中第i个被创建的Point对象。<br>调用showSumOfPoint()输出Point对象的计数统计，输出格式见sample。<br>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-15"><a href="#Sample-Input-15" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1,2</p>
<p>3,3</p>
<p>2,1</p>
<h2 id="Sample-Output-15"><a href="#Sample-Output-15" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point[3] : (1, 2)</p>
<p>Point[1] : (2, 1)</p>
<p>Point[4] : (3, 3)</p>
<p>Point[1] : (3, 3)</p>
<p>Point[5] : (1, 2)</p>
<p>Point[1] : (1, 2)</p>
<p>Point[2] : (0, 0)</p>
<p>==========gorgeous separator==========</p>
<p>Point[2] : (-7, 5)</p>
<p>Point[3] : (1, 2)</p>
<p>Point[4] : (3, 3)</p>
<p>Point[5] : (1, 2)</p>
<p>Point[6] : (-7, 5)</p>
<p>==========gorgeous separator==========</p>
<p>Point[63] : (3, 3)</p>
<p>Point : (3, 3)</p>
<p>Point : (3, 3)</p>
<p>Point : (3, 3)</p>
<p>In total : 64 points.</p>
<h2 id="HINT-15"><a href="#HINT-15" class="headerlink" title="HINT"></a>HINT</h2><p>给函数正确的返回值。注意常量对象调用的函数。</p>
<h2 id="Append-Code-15"><a href="#Append-Code-15" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1126&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point
&#123;

    double m,n;
    int count;
    static int sum;
public :

    friend void ShowPoint(Point);
    friend void ShowPoint(double, double);

    void show()const
    &#123;
        cout&lt;&lt;setprecision(16)&lt;&lt;&quot;Point[&quot;&lt;&lt;count&lt;&lt;&quot;] : (&quot;&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;&quot;)&quot;&lt;&lt;endl;
    &#125;
    double x(double a)
    &#123;
        m = a;
        return a;

    &#125;
    double y(double b)
    &#123;
        n = b;
        return b;
    &#125;
    double x()const
    &#123;
        return m;
    &#125;
    double y()const
    &#123;

        return n;
    &#125;
    Point  &amp;setPoint(double a,double b)
    &#123;
        m=a;
        n=b;
        return *this;
    &#125;void showSumOfPoint()const
    &#123;
        cout &lt;&lt; &quot;In total : &quot; &lt;&lt;sum &lt;&lt; &quot; points.&quot; &lt;&lt; endl;
    &#125;
    Point(double a,double b)
    &#123;

        m = a;
        n = b;
        sum++;
        count =sum;
    &#125;
    Point():m(0),n(0)
    &#123;
        sum++;
        count =sum;
    &#125;
    Point (Point p)
    &#123;
        setPoint(p.getx(),p.gety());
        return *this;
    &#125;
    Point&amp; inverse()
    &#123;
        double temp=m;
        m=n;
        n=temp;
        return *this;
    &#125;
    Point&amp; inverse(Point p)
    &#123;

        m=p.n;
        n=p.m;
        return *this;
    &#125;
    double getx()
    &#123;
     return this-&gt;m;
    &#125;
    double gety()
    &#123;
     return this-&gt;n;
    &#125;

    bool isEqual(const Point &amp;p)const
    &#123;
        if(p.m == m &amp;&amp; p.n == n)
            return true;
        return false;
    &#125;

&#125;;
void ShowPoint(Point p)
&#123;
    cout&lt;&lt;std::setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt; p.x() &lt;&lt;&quot;, &quot;&lt;&lt; p.y() &lt;&lt;&quot;)&quot;&lt;&lt;endl;
&#125;
void ShowPoint(double a,double b)
&#123;
    cout&lt;&lt;std::setprecision(16)&lt;&lt;&quot;Point : (&quot;&lt;&lt;a&lt;&lt;&quot;, &quot;&lt;&lt;b&lt;&lt;&quot;)&quot;&lt;&lt;endl;
&#125;
int Point::sum = 0;
int main()
&#123;
    int l(0);
    char c;
    double a, b;
    Point p, q, pt[60];
    while(std::cin&gt;&gt;a&gt;&gt;c&gt;&gt;b)
    &#123;
        if(a == b)
            p.copy(pt[l].setPoint(a, b));
        if(a &gt; b)
            p.copy(pt[l].setPoint(a, b).inverse());
        if(a &lt; b)
            p.inverse(pt[l].setPoint(a, b));
        if(a &lt; 0)
            q.copy(p).inverse();
        if(b &lt; 0)
            q.inverse(p).copy(pt[l]);
        pt[l++].show();
        p.show();
    &#125;
    q.show();
    cout&lt;&lt;&quot;==========gorgeous separator==========&quot;&lt;&lt;endl;
    double x(0), y(0);
    for(int i = 0; i &lt; l; i++)
        x += pt[i].x(), y -= pt[i].y();
    pt[l].x(y), pt[l].y(x);
    q.copy(pt[l]).show();
    for(int i = 0; i &lt;= l; i++)
        pt[i].show();
    cout&lt;&lt;&quot;==========gorgeous separator==========&quot;&lt;&lt;endl;
    const Point const_point(3, 3);
    const_point.show();
    for(int i = 0; i &lt;= l; i++)
    &#123;
        if(const_point.isEqual(pt[i]))
        &#123;
            ShowPoint(const_point);
            ShowPoint(const_point.x(), const_point.y());
            ShowPoint(Point(const_point.x(), const_point.y()));
        &#125;
    &#125;
    const_point.showSumOfPoint();
&#125;</code></pre>
<h3 id="17-平面上的点和线——Point类、Line类-I"><a href="#17-平面上的点和线——Point类、Line类-I" class="headerlink" title="17.平面上的点和线——Point类、Line类 (I)"></a>17.平面上的点和线——Point类、Line类 (I)</h3><blockquote>
<h2 id="Description-16"><a href="#Description-16" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<h2 id="Input-16"><a href="#Input-16" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。</p>
<p>每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-16"><a href="#Output-16" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<h2 id="Sample-Input-16"><a href="#Sample-Input-16" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4</p>
<p>0,0 1,1</p>
<p>1,1 2,3</p>
<p>2,3 4,5</p>
<p>0,1 1,0</p>
<h2 id="Sample-Output-16"><a href="#Sample-Output-16" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (0, 0)</p>
<p>Line : (0, 0) to (1, 1)</p>
<p>Line : (1, 1) to (2, 3)</p>
<p>Line : (2, 3) to (4, 5)</p>
<p>Line : (0, 1) to (1, 0)</p>
<p>Line : (1, -2) to (2, -1)</p>
<p>Line : (1, -2) to (0, 0)</p>
<p>Line : (2, -1) to (0, 0)</p>
<p>Line : (0, 0) to (2, -1)</p>
<h2 id="HINT-16"><a href="#HINT-16" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-16"><a href="#Append-Code-16" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1327&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Point&#123;
    friend class Line;
public:
    double x,y;
    Point()&#123;x=y=0;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123;&#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (0, 0)&quot; &lt;&lt; endl;&#125;
&#125;;
class Line&#123;
    friend class Point;
public:
    Point p1,p2;
    Line(Point p,Point q):p1(p),p2(q)&#123;&#125;
    Line(double x1,double y1,double x2,double y2):p1(x1,y1),p2(x2,y2)&#123;&#125;
    void show()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;

/////////////////////////////////
int main()
&#123;
    char c;
    int num, i;
    double x1, x2, y1, y2;
    Point p(1, -2), q(2, -1), t;
    t.show();
    std::cin&gt;&gt;num;
    for(i = 1; i &lt;= num; i++)
    &#123;
        std::cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;
        Line line(x1, y1, x2, y2);
        line.show();
    &#125;
    Line l1(p, q), l2(p, t), l3(q, t), l4(t, q);
    l1.show();
    l2.show();
    l3.show();
    l4.show();
&#125;
</code></pre>
<blockquote>
<p><a href="http://www.cnblogs.com/BeyondAnyTime/archive/2012/06/04/2535305.html" target="_blank" rel="noopener">关于C++中的友元函数的总结</a></p>
</blockquote>
<h3 id="18-平面上的点和线——Point类、Line类-II"><a href="#18-平面上的点和线——Point类、Line类-II" class="headerlink" title="18.平面上的点和线——Point类、Line类 (II)"></a>18.平面上的点和线——Point类、Line类 (II)</h3><blockquote>
<h2 id="Description-17"><a href="#Description-17" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<h2 id="Input-17"><a href="#Input-17" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-17"><a href="#Output-17" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<h2 id="Sample-Input-17"><a href="#Sample-Input-17" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4</p>
<p>0,0 1,1</p>
<p>1,1 2,3</p>
<p>2,3 4,5</p>
<p>0,1 1,0</p>
<h2 id="Sample-Output-17"><a href="#Sample-Output-17" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (0, 0)Line : (0, 0) to (1, 1) is created.</p>
<p>Line : (0, 0) to (1, 1)Line : (0, 0) to (1, 1) is erased.</p>
<p>Line : (1, 1) to (2, 3) is created.</p>
<p>Line : (1, 1) to (2, 3)</p>
<p>Line : (1, 1) to (2, 3) is erased.</p>
<p>Line : (2, 3) to (4, 5) is created.</p>
<p>Line : (2, 3) to (4, 5)Line : (2, 3) to (4, 5) is erased.</p>
<p>Line : (0, 1) to (1, 0) is created.</p>
<p>Line : (0, 1) to (1, 0)</p>
<p>Line : (0, 1) to (1, 0) is erased.</p>
<p>Line : (1, -2) to (2, -1) is created.</p>
<p>Line : (1, -2) to (0, 0) is created.</p>
<p>Line : (2, -1) to (0, 0) is created.</p>
<p>Line : (0, 0) to (2, -1) is created.</p>
<p>Line : (1, -2) to (2, -1)</p>
<p>Line : (1, -2) to (0, 0)</p>
<p>Line : (2, -1) to (0, 0)</p>
<p>Line : (0, 0) to (2, -1)</p>
<p>Line : (0, 0) to (2, -1) is erased.</p>
<p>Line : (2, -1) to (0, 0) is erased.</p>
<p>Line : (1, -2) to (0, 0) is erased.</p>
<p>Line : (1, -2) to (2, -1) is erased.</p>
<h2 id="HINT-17"><a href="#HINT-17" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-17"><a href="#Append-Code-17" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1328&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Point&#123;
    friend class Line;
public:
    double x,y;
    Point()&#123;x=y=0;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123;&#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (0, 0)&quot; &lt;&lt; endl;&#125;
&#125;;
class Line&#123;
    friend class Point;
public:
    Point p1,p2;
    Line(Point p,Point q):p1(p),p2(q)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Line(double x1,double y1,double x2,double y2):p1(x1,y1),p2(x2,y2)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Line()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;

/////////////////////////////////
int main()
&#123;
    char c;
    int num, i;
    double x1, x2, y1, y2;
    Point p(1, -2), q(2, -1), t;
    t.show();
    std::cin&gt;&gt;num;
    for(i = 1; i &lt;= num; i++)
    &#123;
        std::cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;
        Line line(x1, y1, x2, y2);
        line.show();
    &#125;
    Line l1(p, q), l2(p, t), l3(q, t), l4(t, q);
    l1.show();
    l2.show();
    l3.show();
    l4.show();
&#125;
</code></pre>
<h3 id="19-平面上的点和线——Point类、Line类-III"><a href="#19-平面上的点和线——Point类、Line类-III" class="headerlink" title="19.平面上的点和线——Point类、Line类 (III)"></a>19.平面上的点和线——Point类、Line类 (III)</h3><blockquote>
<h2 id="Description-18"><a href="#Description-18" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<h2 id="Input-18"><a href="#Input-18" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-18"><a href="#Output-18" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-18"><a href="#Sample-Input-18" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4</p>
<p>0,0 1,1</p>
<p>1,1 2,3</p>
<p>2,3 4,5</p>
<p>0,1 1,0</p>
<h2 id="Sample-Output-18"><a href="#Sample-Output-18" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, -2) is created.</p>
<p>Point : (2, -1) is created.</p>
<p>Point : (0, 0) is created.</p>
<p>Point : (0, 0)</p>
<p>=========================</p>
<p>Point : (0, 0) is created.</p>
<p>Point : (1, 1) is created.</p>
<p>Line : (0, 0) to (1, 1) is created.</p>
<p>Line : (0, 0) to (1, 1)</p>
<p>Line : (0, 0) to (1, 1) is erased.</p>
<p>Point : (1, 1) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>=========================</p>
<p>Point : (1, 1) is created.</p>
<p>Point : (2, 3) is created.</p>
<p>Line : (1, 1) to (2, 3) is created.</p>
<p>Line : (1, 1) to (2, 3)</p>
<p>Line : (1, 1) to (2, 3) is erased.</p>
<p>Point : (2, 3) is erased.</p>
<p>Point : (1, 1) is erased.</p>
<p>=========================</p>
<p>Point : (2, 3) is created.</p>
<p>Point : (4, 5) is created.</p>
<p>Line : (2, 3) to (4, 5) is created.</p>
<p>Line : (2, 3) to (4, 5)</p>
<p>Line : (2, 3) to (4, 5) is erased.</p>
<p>Point : (4, 5) is erased.</p>
<p>Point : (2, 3) is erased.</p>
<p>=========================</p>
<p>Point : (0, 1) is created.</p>
<p>Point : (1, 0) is created.</p>
<p>Line : (0, 1) to (1, 0) is created.</p>
<p>Line : (0, 1) to (1, 0)</p>
<p>Line : (0, 1) to (1, 0) is erased.</p>
<p>Point : (1, 0) is erased.</p>
<p>Point : (0, 1) is erased.</p>
<p>=========================</p>
<p>Point : (1, -2) is copied.</p>
<p>Point : (2, -1) is copied.</p>
<p>Line : (1, -2) to (2, -1) is created.</p>
<p>Point : (1, -2) is copied.</p>
<p>Point : (0, 0) is copied.</p>
<p>Line : (1, -2) to (0, 0) is created.</p>
<p>Point : (2, -1) is copied.</p>
<p>Point : (0, 0) is copied.</p>
<p>Line : (2, -1) to (0, 0) is created.</p>
<p>Point : (0, 0) is copied.</p>
<p>Point : (2, -1) is copied.</p>
<p>Line : (0, 0) to (2, -1) is created.</p>
<p>Line : (1, -2) to (2, -1)</p>
<p>Line : (1, -2) to (0, 0)</p>
<p>Line : (2, -1) to (0, 0)</p>
<p>Line : (0, 0) to (2, -1)</p>
<p>Line : (0, 0) to (2, -1) is erased.</p>
<p>Point : (2, -1) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Line : (2, -1) to (0, 0) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (2, -1) is erased.</p>
<p>Line : (1, -2) to (0, 0) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (1, -2) is erased.</p>
<p>Line : (1, -2) to (2, -1) is erased.</p>
<p>Point : (2, -1) is erased.</p>
<p>Point : (1, -2) is erased.</p>
<p>Point : (0, 0) is erased.</p>
<p>Point : (2, -1) is erased.</p>
<p>Point : (1, -2) is erased.</p>
<h2 id="HINT-18"><a href="#HINT-18" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-18"><a href="#Append-Code-18" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1329&getkey=" target="_blank" rel="noopener">append.cc</a>, </p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Point&#123;
    friend class Line;
public:
    double x,y;
    Point()&#123;x=y=0;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(const Point&amp; p)&#123;x=p.x;y=p.y; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is copied.&quot; &lt;&lt; endl;  &#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (0, 0)&quot; &lt;&lt; endl;&#125;
     ~Point ()  &#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is erased.&quot; &lt;&lt; endl;&#125;  
&#125;;
class Line&#123;
    friend class Point;
public:
    Point p1,p2;
    Line(Point &amp;p,Point &amp;q):p1(p),p2(q)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Line(double x1,double y1,double x2,double y2):p1(x1,y1),p2(x2,y2)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Line()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
////////////////////////////////
int main()
&#123;
    char c;
    int num, i;
    double x1, x2, y1, y2;
    Point p(1, -2), q(2, -1), t;
    t.show();
    std::cin&gt;&gt;num;
    for(i = 1; i &lt;= num; i++)
    &#123;
        std::cout&lt;&lt;&quot;=========================\n&quot;;
        std::cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;
        Line line(x1, y1, x2, y2);
        line.show();
    &#125;
    std::cout&lt;&lt;&quot;=========================\n&quot;;
    Line l1(p, q), l2(p, t), l3(q, t), l4(t, q);
    l1.show();
    l2.show();
    l3.show();
    l4.show();
&#125;</code></pre>
<h3 id="20-平面上的点和线——Point类、Line类-IV"><a href="#20-平面上的点和线——Point类、Line类-IV" class="headerlink" title="20.平面上的点和线——Point类、Line类 (IV)"></a>20.平面上的点和线——Point类、Line类 (IV)</h3><blockquote>
<h2 id="Description-19"><a href="#Description-19" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<h2 id="Input-19"><a href="#Input-19" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。</p>
<p>每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-19"><a href="#Output-19" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-19"><a href="#Sample-Input-19" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4</p>
<p>0,0 1,1</p>
<p>1,1 2,3</p>
<p>2,3 4,5</p>
<p>0,1 1,0</p>
<h2 id="Sample-Output-19"><a href="#Sample-Output-19" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, -2) is created.Point : (2, -1) is created.Point : (0, 0) is created.Point : (0, 0)Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.=========================Line : (0, 0) to (1, 1)=========================Line : (1, 1) to (2, 3)=========================Line : (2, 3) to (4, 5)=========================Line : (0, 1) to (1, 0)=========================Point : (1, -2) is copied.Point : (2, -1) is copied.Line : (1, -2) to (2, -1) is created.Point : (1, -2) is copied.Point : (0, 0) is copied.Line : (1, -2) to (0, 0) is created.Point : (2, -1) is copied.Point : (0, 0) is copied.Line : (2, -1) to (0, 0) is created.Point : (0, 0) is copied.Point : (2, -1) is copied.Line : (0, 0) to (2, -1) is created.Line : (1, -2) to (2, -1)Line : (1, -2) to (0, 0)Line : (2, -1) to (0, 0)Line : (0, 0) to (2, -1)Line : (0, 0) to (2, -1) is erased.Point : (2, -1) is erased.Point : (0, 0) is erased.Line : (2, -1) to (0, 0) is erased.Point : (0, 0) is erased.Point : (2, -1) is erased.Line : (1, -2) to (0, 0) is erased.Point : (0, 0) is erased.Point : (1, -2) is erased.Line : (1, -2) to (2, -1) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.Line : (0, 1) to (1, 0) is erased.Point : (1, 0) is erased.Point : (0, 1) is erased.Line : (2, 3) to (4, 5) is erased.Point : (4, 5) is erased.Point : (2, 3) is erased.Line : (1, 1) to (2, 3) is erased.Point : (2, 3) is erased.Point : (1, 1) is erased.Line : (0, 0) to (1, 1) is erased.Point : (1, 1) is erased.Point : (0, 0) is erased.Point : (0, 0) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.</p>
<h2 id="HINT-19"><a href="#HINT-19" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-19"><a href="#Append-Code-19" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1330&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Point&#123;
    friend class Line;
public:
    double x,y;
    Point()&#123;x=y=0;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(const Point&amp; p)&#123;x=p.x;y=p.y; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is copied.&quot; &lt;&lt; endl;  &#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (0, 0)&quot; &lt;&lt; endl;&#125;
     ~Point ()  &#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is erased.&quot; &lt;&lt; endl;&#125;  
&#125;;
class Line&#123;
    friend class Point;
public:
    Point p1,p2;
    Line():p1(0,0),p2(0,0)&#123;cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;p1.x&lt;&lt;&quot;, &quot;&lt;&lt;p1.y&lt;&lt;&quot;) to (&quot;&lt;&lt;p2.x&lt;&lt;&quot;, &quot;&lt;&lt;p2.y&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;&#125;
    Line(Point &amp;p,Point &amp;q):p1(p),p2(q)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Line(double x1,double y1,double x2,double y2):p1(x1,y1),p2(x2,y2)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Line()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    void SetLine(double a,double b,double c,double d)  
    &#123;  
        p1.x = a;  
        p1.y = b;  
        p2.x = c;  
        p2.y = d;  
    &#125;  
&#125;;
//////////////////////////////
int main()
&#123;
    char c;
    int num, i;
    double x1, x2, y1, y2;
    Point p(1, -2), q(2, -1), t;
    t.show();
    std::cin&gt;&gt;num;
    Line line[num];
    for(i = 0; i &lt; num; i++)
    &#123;
        std::cout&lt;&lt;&quot;=========================\n&quot;;
        std::cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;
        line[i].SetLine(x1, y1, x2, y2);
        line[i].show();
    &#125;
    std::cout&lt;&lt;&quot;=========================\n&quot;;
    Line l1(p, q), l2(p, t), l3(q, t), l4(t, q);
    l1.show();
    l2.show();
    l3.show();
    l4.show();
&#125;</code></pre>
<h3 id="21-平面上的点和线——Point类、Line类-V"><a href="#21-平面上的点和线——Point类、Line类-V" class="headerlink" title="21.平面上的点和线——Point类、Line类 (V)"></a>21.平面上的点和线——Point类、Line类 (V)</h3><blockquote>
<h2 id="Description-20"><a href="#Description-20" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<p>Line::SetLine(double, double, double, double)方法：设置Line对象起点的x,y坐标（第一个和第二参数）和终点的x,y坐标（第三个和第四个坐标），并返回本对象</p>
<p>Line::SetLine(const Point &amp;, const Point &amp;)方法：设置Line对象的起点（第一个参数）和终点（第二个坐标），并返回本对象</p>
<p>Line::SetLine(const Line&amp;)方法：设置Line对象，复制参数的坐标，并返回本对象</p>
<p>Line::readLine()方法：从标准输入上读入坐标，格式见Sample</p>
<h2 id="Input-20"><a href="#Input-20" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。</p>
<p>每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-20"><a href="#Output-20" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-20"><a href="#Sample-Input-20" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4</p>
<p>0,0 1,1</p>
<p>1,1 2,3</p>
<p>2,3 4,5</p>
<p>0,1 1,0</p>
<h2 id="Sample-Output-20"><a href="#Sample-Output-20" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, -2) is created.Point : (2, -1) is created.Point : (0, 0) is created.Point : (0, 0)Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Line : (0, 0) to (1, 1)Line : (1, 1) to (2, 3)Line : (2, 3) to (4, 5)Line : (0, 1) to (1, 0)Point : (1, -2) is copied.Point : (2, -1) is copied.Line : (1, -2) to (2, -1) is created.Point : (1, -2) is copied.Point : (0, 0) is copied.Line : (1, -2) to (0, 0) is created.Point : (2, -1) is copied.Point : (0, 0) is copied.Line : (2, -1) to (0, 0) is created.Point : (1, -2) is copied.Point : (2, -1) is copied.Line : (1, -2) to (2, -1) is copied.Line : (1, -2) to (2, -1)Line : (1, -2) to (2, -1)Line : (2, -1) to (0, 0)Line : (0, 0) to (2, -1)Line : (0, 0) to (2, -1) is erased.Point : (2, -1) is erased.Point : (0, 0) is erased.Line : (2, -1) to (0, 0) is erased.Point : (0, 0) is erased.Point : (2, -1) is erased.Line : (1, -2) to (2, -1) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.Line : (1, -2) to (2, -1) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.Line : (0, 1) to (1, 0) is erased.Point : (1, 0) is erased.Point : (0, 1) is erased.Line : (2, 3) to (4, 5) is erased.Point : (4, 5) is erased.Point : (2, 3) is erased.Line : (1, 1) to (2, 3) is erased.Point : (2, 3) is erased.Point : (1, 1) is erased.Line : (0, 0) to (1, 1) is erased.Point : (1, 1) is erased.Point : (0, 0) is erased.Point : (0, 0) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.</p>
<h2 id="HINT-20"><a href="#HINT-20" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-20"><a href="#Append-Code-20" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1331&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Point&#123;
    friend class Line;
public:
    double x,y;
    Point()&#123;x=y=0;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(double xx,double yy):x(xx),y(yy)&#123; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is created.&quot; &lt;&lt; endl;&#125;
    Point(const Point&amp; p)&#123;x=p.x;y=p.y; cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is copied.&quot; &lt;&lt; endl;  &#125;
    void show()&#123;cout &lt;&lt; &quot;Point : (0, 0)&quot; &lt;&lt; endl;&#125;
     ~Point ()  &#123;cout &lt;&lt; &quot;Point : (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt;&quot;) is erased.&quot; &lt;&lt; endl;&#125;  
&#125;;
class Line&#123;
    friend class Point;
public:
    Point p1,p2;
    Line():p1(0,0),p2(0,0)&#123;cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;p1.x&lt;&lt;&quot;, &quot;&lt;&lt;p1.y&lt;&lt;&quot;) to (&quot;&lt;&lt;p2.x&lt;&lt;&quot;, &quot;&lt;&lt;p2.y&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;&#125;
    Line(Point &amp;p,Point &amp;q):p1(p),p2(q)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    Line(double x1,double y1,double x2,double y2):p1(x1,y1),p2(x2,y2)&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is created.&quot; &lt;&lt; endl;&#125;
    ~Line()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;) is erased.&quot; &lt;&lt; endl;&#125;
    void show()&#123;cout &lt;&lt; &quot;Line : (&quot; &lt;&lt; p1.x &lt;&lt; &quot;, &quot; &lt;&lt; p1.y &lt;&lt; &quot;) to (&quot; &lt;&lt; p2.x &lt;&lt; &quot;, &quot; &lt;&lt; p2.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    void readLine()&#123;
        double x1, y1, x2, y2;  
        char c;  
        cin &gt;&gt; x1 &gt;&gt; c &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; c &gt;&gt; y2;  
        SetLine(x1, y1, x2, y2);  

    &#125;
    Line&amp; SetLine(double a,double b,double c,double d)  
    &#123;  
        p1.x = a;  
        p1.y = b;  
        p2.x = c;  
        p2.y = d;
        return *this;  
    &#125;  
    Line&amp; setLine(const Point&amp; p, const Point&amp; q)&#123;
        p1.x = p.x;  
        p1.y = p.y;  
        p2.x = q.x;  
        p2.y = q.y;
        return *this;         
    &#125;
    Line&amp; setLine(const Line&amp; l)&#123;
        p1.x = l.p1.x;  
        p1.y = l.p1.y;  
        p2.x = l.p2.x;  
        p2.y = l.p2.y;
        return *this;         
    &#125;
&#125;;
/////////////////////////
int main()
&#123;
    int num, i;
    Point p(1, -2), q(2, -1), t;
    t.show();
    std::cin&gt;&gt;num;
    Line line[num];
    for(i = 0; i &lt; num; i++)
    &#123;
        line[i].readLine();
        line[i].show();
    &#125;
    Line l1(p, q), l2(p,t), l3(q,t), l4(l1);
    l1.show();
    l2.setLine(l1).show();
    l3.show();
    l4.setLine(t,q).show();
&#125;</code></pre>
<h3 id="22-平面上的点和线——Point类、Line类-VI"><a href="#22-平面上的点和线——Point类、Line类-VI" class="headerlink" title="22.平面上的点和线——Point类、Line类 (VI)"></a>22.平面上的点和线——Point类、Line类 (VI)</h3><blockquote>
<h2 id="Description-21"><a href="#Description-21" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::show()方法：按格式输出Point对象。</p>
<p>Point::x()方法：取x坐标。</p>
<p>Point::y()方法：取y坐标。</p>
<p>Line::show()方法：按格式输出Line对象。</p>
<p>Line::SetLine(double, double, double, double)方法：设置Line对象起点的x,y坐标（第一个和第二参数）和终点的x,y坐标（第三个和第四个坐标），并返回本对象</p>
<p>Line::SetLine(const Point &amp;, const Point &amp;)方法：设置Line对象的起点（第一个参数）和终点（第二个坐标），并返回本对象</p>
<p>Line::SetLine(const Line&amp;)方法：设置Line对象，复制参数的坐标，并返回本对象</p>
<p>Line::readLine()方法：从标准输入上读入坐标，格式见Sample</p>
<p>Line::start()方法：取Line的起点</p>
<p>Line::end()方法：取Line的终点</p>
<p>Line::setStart()方法：设置Line的起点</p>
<p>Line::setEnd()方法：设置Line的终点</p>
<p>以下三个函数用于输出Line对象，格式同sample</p>
<p>showLineCoordinate(const Line&amp;)</p>
<p>showLinePoint(const Line&amp;)</p>
<p>showLine(const Line&amp;)</p>
<h2 id="Input-21"><a href="#Input-21" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。</p>
<p>每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-21"><a href="#Output-21" class="headerlink" title="Output"></a>Output</h2><p>输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-21"><a href="#Sample-Input-21" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>40,0 1,11,1 2,32,3 4,50,1 1,0</p>
<h2 id="Sample-Output-21"><a href="#Sample-Output-21" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Point : (1, -2) is created.Point : (2, -1) is created.Point : (0, 0) is created.Point : (0, 0)Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Point : (0, 0) is created.Point : (0, 0) is created.Line : (0, 0) to (0, 0) is created.Line : (0, 0) to (1, 1)Line : (1, 1) to (2, 3)Line : (2, 3) to (4, 5)Line : (0, 1) to (1, 0)Point : (1, -2) is copied.Point : (2, -1) is copied.Line : (1, -2) to (2, -1) is created.Point : (1, -2) is copied.Point : (0, 0) is copied.Line : (1, -2) to (0, 0) is created.Point : (2, -1) is copied.Point : (0, 0) is copied.Line : (2, -1) to (0, 0) is created.Point : (1, -2) is copied.Point : (2, -1) is copied.Line : (1, -2) to (2, -1) is copied.Line : (1, -2) to (2, -1)Line : Point : (1, -2) to Point : (0, 0)Line : Point : (1, -2) to Point : (2, -1)Line : (0, 0) to (2, -1)Line : (0, 0) to (2, -1) is erased.Point : (2, -1) is erased.Point : (0, 0) is erased.Line : (1, -2) to (2, -1) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.Line : (1, -2) to (0, 0) is erased.Point : (0, 0) is erased.Point : (1, -2) is erased.Line : (1, -2) to (2, -1) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.Line : (0, 1) to (1, 0) is erased.Point : (1, 0) is erased.Point : (0, 1) is erased.Line : (2, 3) to (4, 5) is erased.Point : (4, 5) is erased.Point : (2, 3) is erased.Line : (1, 1) to (2, 3) is erased.Point : (2, 3) is erased.Point : (1, 1) is erased.Line : (0, 0) to (1, 1) is erased.Point : (1, 1) is erased.Point : (0, 0) is erased.Line : (0, 0) to (2, -1) is erased.Point : (2, -1) is erased.Point : (0, 0) is erased.Point : (0, 0) is erased.Point : (2, -1) is erased.Point : (1, -2) is erased.</p>
<h2 id="HINT-21"><a href="#HINT-21" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-21"><a href="#Append-Code-21" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1332&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;  
using namespace std;  
#include &lt;iomanip&gt;  
class Point&#123;  
private:  
    double x_,y_;  
    friend class Line;  
public:  
    Point(double x,double y)  
    &#123;  
        x_ = x;  
        y_ = y;  
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;  
    &#125;  
    Point()  
    &#123;  
        x_ = 0;  
        y_ = 0;  
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;  
    &#125;  
    Point(double a):x_(a),y_(a) &#123; cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;&#125;  
    void setvalue(double xx,double yy)  
    &#123;  
        x_ = xx;  
        y_ = yy;  
    &#125;  
    //void setx(int xx) &#123;x_ = xx;&#125;  
    //void sety(int yy) &#123;y_ = yy;&#125;  
    void show()  
    &#123;  
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
    &#125;  
    double x() const &#123; return x_;&#125;  
    double y() const &#123; return y_;&#125;  
    Point(const Point &amp;p)  
    &#123;  
        x_ = p.x_;  
        y_ = p.y_;  
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is copied.&quot;&lt;&lt;endl;  
    &#125;  
    ~Point()  
    &#123;  
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is erased.&quot;&lt;&lt;endl;  
    &#125;  
    void showNoEndOfLine()const&#123;cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;)&quot;;&#125;  
&#125;;  

class Line&#123;  
private:  
    Point x1_,y1_;  
    double x1,y1,x2,y2;  
    friend class Point;  
public:  
    Line(double xx1,double yy1,double xx2,double yy2):x1_(xx1,yy1),y1_(xx2,yy2)  
    &#123;  
        cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;  
    &#125;  
    Line(Point &amp;q1,Point &amp;q2):x1_(q1),y1_(q2)  
    &#123;  
        cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;  
    &#125;  
    Line(const Line&amp;I):x1_(I.x1_),y1_(I.y1_) &#123;cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is copied.&quot;&lt;&lt;endl;&#125;  
    Line():x1_(),y1_()&#123;cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;&#125;  
    Line &amp;setLine(double xx3,double yy3,double xx4,double yy4)  
    &#123;  
        x1_.x_ = xx3;  
        x1_.y_ = yy3;  
        y1_.x_ = xx4;  
        y1_.y_ = yy4;  
        return *this;  
    &#125;  
    void show() const  
    &#123;  
        cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
    &#125;  
    ~Line()  
    &#123;  
        cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is erased.&quot;&lt;&lt;endl;  
    &#125;  
    Line &amp;setLine(const Point &amp;p1,const Point &amp;p2)  
    &#123;  
        x1_ = p1;  
        y1_ = p2;  
        return *this;  
    &#125;  
    Line &amp;setLine(const Line&amp; q)  
    &#123;  
       *this = q;  
       return *this;  
    &#125;  
    void readLine()  
    &#123;  
       double x1,y1,x2,y2;  
       char c;  
       cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;  
       x1_.x_ = x1;  
       x1_.y_ = y1;  
       y1_.x_ = x2;  
       y1_.y_ = y2;  
    &#125;  
    const Point &amp;start() const  
    &#123;  
        return x1_;  
    &#125;  
    const Point &amp;end() const  
    &#123;  
        return y1_;  
    &#125;  
    void setStart(Point &amp;c) &#123;x1_ = c;&#125;  
    void setEnd(Point &amp;e) &#123;y1_ = e;&#125;  
&#125;;  
void showLineCoordinate(const Line&amp; line)  
&#123;  
    std::cout&lt;&lt;&quot;Line : &quot;;  
    std::cout&lt;&lt;&quot;(&quot;&lt;&lt;line.start().x()&lt;&lt;&quot;, &quot;&lt;&lt;line.start().y()&lt;&lt;&quot;)&quot;;  
    std::cout&lt;&lt;&quot; to &quot;;  
    std::cout&lt;&lt;&quot;(&quot;&lt;&lt;line.end().x()&lt;&lt;&quot;, &quot;&lt;&lt;line.end().y()&lt;&lt;&quot;)&quot;;  
    std::cout&lt;&lt;std::endl;  
&#125;  

void showLinePoint(const Line&amp; line)  
&#123;  
    std::cout&lt;&lt;&quot;Line : &quot;;  
    line.start().showNoEndOfLine();  
    std::cout&lt;&lt;&quot; to &quot;;  
    line.end().showNoEndOfLine();  
    std::cout&lt;&lt;std::endl;  
&#125;  

void showLine(const Line&amp; line)  
&#123;  
    line.show();  
&#125;  

int main()  
&#123;  
    int num, i;  
    Point p(1, -2), q(2, -1), t;  
    t.show();  
    std::cin&gt;&gt;num;  
    Line line[num + 1];  
    for(i = 1; i &lt;= num; i++)  
    &#123;  
        line[i].readLine();  
        showLine(line[i]);  
    &#125;  
    Line l1(p, q), l2(p,t), l3(q,t), l4(l1);  
    showLineCoordinate(l1);  
    showLinePoint(l2);  
    showLinePoint(l3.setLine(l1));  
    showLineCoordinate(l4.setLine(t,q));  
    line[0].setStart(t);  
    line[0].setEnd(q);  
&#125;  1</code></pre>
<h3 id="23-平面上的点和线——Point类、Line类-VII"><a href="#23-平面上的点和线——Point类、Line类-VII" class="headerlink" title="23.平面上的点和线——Point类、Line类 (VII)"></a>23.平面上的点和线——Point类、Line类 (VII)</h3><blockquote>
<h2 id="Description-22"><a href="#Description-22" class="headerlink" title="Description"></a>Description</h2><p>在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。</p>
<p>根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。</p>
<p>接口描述：</p>
<p>Point::showCounter()方法：按格式输出当前程序中Point对象的计数。</p>
<p>Point::showSum()方法：按格式输出程序运行至当前存在过的Point对象总数。</p>
<p>Line::showCounter()方法：按格式输出当前程序中Line对象的计数。</p>
<p>Line::showSum()方法：按格式输出程序运行至当前存在过的Line对象总数。</p>
<h2 id="Input-22"><a href="#Input-22" class="headerlink" title="Input"></a>Input</h2><p>输入的第一行为N，表示后面有N行测试样例。</p>
<p>每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。</p>
<h2 id="Output-22"><a href="#Output-22" class="headerlink" title="Output"></a>Output</h2><p>输出格式见sample。</p>
<p>C语言的输入输出被禁用。</p>
<h2 id="Sample-Input-22"><a href="#Sample-Input-22" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>40,0 1,11,1 2,32,3 4,50,1 1,0</p>
<h2 id="Sample-Output-22"><a href="#Sample-Output-22" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Current : 3 points.In total : 3 points.Current : 6 lines.In total : 6 lines.Current : 17 points.In total : 17 points.Current : 6 lines.In total : 7 lines.Current : 15 points.In total : 17 points.Current : 6 lines.In total : 8 lines.Current : 17 points.In total : 21 points.Current : 6 lines.In total : 9 lines.Current : 15 points.In total : 21 points.Current : 6 lines.In total : 10 lines.Current : 17 points.In total : 25 points.Current : 6 lines.In total : 11 lines.Current : 15 points.In total : 25 points.Current : 6 lines.In total : 12 lines.Current : 17 points.In total : 29 points.Current : 6 lines.In total : 13 lines.Current : 15 points.In total : 29 points.Current : 9 lines.In total : 17 lines.Current : 21 points.In total : 37 points.Current : 13 lines.In total : 21 lines.Current : 21 points.In total : 45 points.</p>
<h2 id="HINT-22"><a href="#HINT-22" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-22"><a href="#Append-Code-22" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1333&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;iomanip&gt;
class Point&#123;
private:
    double x_,y_;
    friend class Line;
    static int sta1;
    static int sta2;
public:
    Point(double x,double y)
    &#123;
        x_ = x;
        y_ = y;
        sta1++;
        sta2++;
        //cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;
    &#125;
    Point(double d)
    &#123;
        x_ = d;
        y_ = d;
        sta1++;
        sta2++;
    &#125;
    Point()
    &#123;
        x_ = 0;
        y_ = 0;
        sta1++;
        sta2++;
        //cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;
    &#125;
    void setvalue(double xx,double yy)
    &#123;
        x_ = xx;
        y_ = yy;
    &#125;
    void setx(int xx) &#123;x_ = xx;&#125;
    void sety(int yy) &#123;y_ = yy;&#125;
    void show()
    &#123;
        cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;)&quot;&lt;&lt;endl;
    &#125;
    int x() &#123; return x_;&#125;
    int y() &#123; return y_;&#125;
    Point(const Point &amp;p)
    &#123;
        sta1++;
        sta2++;
        x_ = p.x_;
        y_ = p.y_;
        //cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is copied.&quot;&lt;&lt;endl;
    &#125;
    ~Point()
    &#123;
       sta1 = sta1 - 1;
        //cout&lt;&lt;&quot;Point : (&quot;&lt;&lt;x_&lt;&lt;&quot;, &quot;&lt;&lt;y_&lt;&lt;&quot;) is erased.&quot;&lt;&lt;endl;
    &#125;
    static void showCounter()
    &#123;
        cout&lt;&lt;&quot;Current : &quot;&lt;&lt;sta1&lt;&lt;&quot; points.&quot;&lt;&lt;endl;
    &#125;
    static void showSum()
    &#123;
        cout&lt;&lt;&quot;In total : &quot;&lt;&lt;sta2&lt;&lt;&quot; points.&quot;&lt;&lt;endl;
    &#125;
&#125;;
 int Point::sta1(0);
 int Point::sta2(0);
class Line&#123;friend class Point;
private:
    Point x1_,y1_;
    double x1,y1,x2,y2;


public:static int sta3;
    static int sta4;
    Line(double xx1,double yy1,double xx2,double yy2):x1_(xx1,yy1),y1_(xx2,yy2)
    &#123;
        sta3++;
        sta4++;
        //cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;
    &#125;
    Line(Point &amp;q1,Point &amp;q2):x1_(q1),y1_(q2)
    &#123;
        sta3++;
        sta4++;
        //cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;
    &#125;
    Line():x1_(),y1_()&#123;sta3++; sta4++;/*cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is created.&quot;&lt;&lt;endl;*/&#125;
    Line setLine(double xx3,double yy3,double xx4,double yy4)
    &#123;

        sta3++;
        sta4++;
        x1_.x_ = xx3;
        x1_.y_ = yy3;
        y1_.x_ = xx4;
        y1_.y_ = yy4;
        return *this;
    &#125;
    void show()
    &#123;
        cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;)&quot;&lt;&lt;endl;
    &#125;
    ~Line()
    &#123;
        sta3 = sta3 - 1;
        //cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is erased.&quot;&lt;&lt;endl;
    &#125;
    Line &amp;setLine(const Point &amp;p1,const Point &amp;p2)
    &#123;
        x1_ = p1;
        y1_ = p2;
        return *this;
    &#125;
    Line &amp;setLine(const Line&amp; q)
    &#123;
       x1_ = q.x1_;
       y1_ = q.y1_;
       return *this;
    &#125;
    void readLine()
    &#123;
       double x1,y1,x2,y2;
       char c;
       cin&gt;&gt;x1&gt;&gt;c&gt;&gt;y1&gt;&gt;x2&gt;&gt;c&gt;&gt;y2;
       x1_.x_ = x1;
       x1_.y_ = y1;
       y1_.x_ = x2;
       y1_.y_ = y2;
    &#125;
    Line(const Line &amp;b):x1_(b.x1_),y1_(b.y1_)
    &#123;
        sta3++;
        sta4++;
        //cout&lt;&lt;&quot;Line : (&quot;&lt;&lt;x1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;x1_.y_&lt;&lt;&quot;) to (&quot;&lt;&lt;y1_.x_&lt;&lt;&quot;, &quot;&lt;&lt;y1_.y_&lt;&lt;&quot;) is copied.&quot;&lt;&lt;endl;
    &#125;
    static void showCounter()
    &#123;
        cout&lt;&lt;&quot;Current : &quot;&lt;&lt;sta3&lt;&lt;&quot; lines.&quot;&lt;&lt;endl;
    &#125;
    static void showSum()
    &#123;
        cout&lt;&lt;&quot;In total : &quot;&lt;&lt;sta4&lt;&lt;&quot; lines.&quot;&lt;&lt;endl;
    &#125;
&#125;;
int Line::sta3 = 0;
int Line::sta4(0);

int main()
&#123;
    int num, i;
    Point p(1, -2), q(2, -1), t;
    t.showCounter();
    t.showSum();
    std::cin&gt;&gt;num;
    Line line[num + 1];
    for(i = 1; i &lt;= num; i++)
    &#123;
        Line *l1, l2;
        l1-&gt;showCounter();
        l1-&gt;showSum();
        l1 = new Line(p, q);
        line[i].readLine();
        p.showCounter();
        p.showSum();
        delete l1;
        l2.showCounter();
        l2.showSum();
        q.showCounter();
        q.showSum();
    &#125;
    Line l1(p, q), l2(p,t), l3(q,t), l4(l1);
    Line::showCounter();
    Line::showSum();
    Point::showCounter();
    Point::showSum();
    Line *l = new Line[num];
    l4.showCounter();
    l4.showSum();
    delete[] l;
    t.showCounter();
    t.showSum();
&#125;

</code></pre>
<h3 id="24-时间类的构造和输出"><a href="#24-时间类的构造和输出" class="headerlink" title="24.时间类的构造和输出"></a>24.时间类的构造和输出</h3><blockquote>
<h2 id="Description-23"><a href="#Description-23" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\2. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-23"><a href="#Input-23" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在合法的时间范围内。</p>
<h2 id="Output-23"><a href="#Output-23" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0，格式见sample。</p>
<h2 id="Sample-Input-23"><a href="#Sample-Input-23" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5</p>
<p>0 0 1</p>
<p>0 59 59</p>
<p>1 1 12</p>
<p>3 0 02</p>
<p>3 59 59</p>
<h2 id="Sample-Output-23"><a href="#Sample-Output-23" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>00:00:01</p>
<p>00:59:59</p>
<p>01:01:01</p>
<p>23:00:00</p>
<p>23:59:59</p>
<h2 id="HINT-23"><a href="#HINT-23" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-23"><a href="#Append-Code-23" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1385&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
public:
    int h,m,s;
    Time(int hh,int mm,int ss):h(hh),m(mm),s(ss)&#123;&#125;
    void showTime()&#123;
        cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
    &#125;
&#125;;
////////////////////////////////
int main()
&#123;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        int hour, minute, second;
        cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
        Time t(hour, minute, second);
        t.showTime();
    &#125;
&#125;</code></pre>
<blockquote>
<p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
</blockquote>
<h3 id="25-时间类的成员读写"><a href="#25-时间类的成员读写" class="headerlink" title="25.时间类的成员读写"></a>25.时间类的成员读写</h3><blockquote>
<h2 id="Description-24"><a href="#Description-24" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. 成员读函数：</p>
<p>   Time::hour()  ：返回Time的小时数；</p>
<p>   Time::minute()：返回Time的分钟数；</p>
<p>   Time::second()：返回Time的秒数。</p>
<p>\3. 成员写函数：</p>
<p>   Time::hour(int)  ：传参修改Time的小时数；</p>
<p>   Time::minute(int)：传参修改Time的分钟数；</p>
<p>   Time::second(int)：传参修改Time的秒数。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-24"><a href="#Input-24" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在合法的时间范围内。</p>
<h2 id="Output-24"><a href="#Output-24" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0，格式见sample。</p>
<h2 id="Sample-Input-24"><a href="#Sample-Input-24" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5</p>
<p>0 0 1</p>
<p>0 59 59</p>
<p>1 1 12</p>
<p>3 0 02</p>
<p>3 59 59</p>
<h2 id="Sample-Output-24"><a href="#Sample-Output-24" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>00:00:01</p>
<p>00:59:59</p>
<p>01:01:01</p>
<p>23:00:00</p>
<p>23:59:59</p>
<h2 id="HINT-24"><a href="#HINT-24" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-24"><a href="#Append-Code-24" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1386&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
public:
    int h,m,s;
    Time()&#123;&#125;
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;
    int hour()&#123;return h;&#125;
    int minute()&#123;return m;&#125;
    int second()&#123;return s;&#125;
&#125;;
////////////////////////////////
int main()
&#123;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        int hour, minute, second;
        cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
        t.hour(hour);
        t.minute(minute);
        t.second(second);
        cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;t.hour()&lt;&lt;&quot;:&quot;;
        cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;t.minute()&lt;&lt;&quot;:&quot;;
        cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;t.second()&lt;&lt;endl;
    &#125;
&#125;</code></pre>
<h3 id="26-时间类的输入"><a href="#26-时间类的输入" class="headerlink" title="* 26.时间类的输入"></a>* 26.时间类的输入</h3><p>Description</p>
<blockquote>
<h2 id="Description-25"><a href="#Description-25" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::inputTime()方法：按格式从标准输入读取数据修改Time对象的时分秒数值。该方法返回修改后的对象。</p>
<p>\3. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-25"><a href="#Input-25" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在合法的时间范围内。</p>
<h2 id="Output-25"><a href="#Output-25" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0，格式见sample。</p>
<h2 id="Sample-Input-25"><a href="#Sample-Input-25" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>50 0 10 59 591 1 123 0 023 59 59</p>
<h2 id="Sample-Output-25"><a href="#Sample-Output-25" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>00:00:0100:59:5901:01:0123:00:0023:59:59</p>
<h2 id="HINT-25"><a href="#HINT-25" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-25"><a href="#Append-Code-25" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1387&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
public:
    int h,m,s;
    Time()&#123;&#125;
    Time(int hh, int mm, int ss) : s(ss), m(mm), h(hh) &#123; &#125;  
    Time&amp; inputTime()  
    &#123;  
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s;  
        return *this;  
    &#125;      
    void showTime()&#123;
        cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
    &#125;
&#125;;
///////////////////////////
int main()
&#123;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
        t.inputTime().showTime();
&#125;</code></pre>
<h3 id="27-时间类的拷贝和整体读写"><a href="#27-时间类的拷贝和整体读写" class="headerlink" title="27.时间类的拷贝和整体读写"></a>27.时间类的拷贝和整体读写</h3><blockquote>
<h2 id="Description-26"><a href="#Description-26" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\3. Time::Time(const T&amp;)拷贝构造方法。拷贝构造函数调用时输出“There was a call to the copy constructor : h,m,s”，“h,m,s”为所构造对象的时分秒数值，无需补0。</p>
<p>\4. 对象整体读写方法：</p>
<p>   Time::setTime(int,int,int)方法：传递时分秒三个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::setTime(const T&amp;)方法：传递一个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::getTime()方法：返回对象自身的引用。其实，t.getTime()即t。</p>
<p>   仅在Time类中的Time::getTime()方法实在是多余，在组合或者继承关系时才会有机会用到。</p>
<p>\5. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。</p>
<p>注意：在用Time对象传递参数时应传对象的引用而不是直接传对象，返回对象时同样返回引用，以免产生多余的对象拷贝。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。main()函数内容稍微繁复，仅为测试对象的各种调用情况。</p>
<h2 id="Input-26"><a href="#Input-26" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在合法的时间范围内。</p>
<h2 id="Output-26"><a href="#Output-26" class="headerlink" title="Output"></a>Output</h2><p>开始部分为由main()函数产生的固定输出，用于测试对象的某些方法的调用情况。输出“Test data output :”之后为测试数据对应的输出：</p>
<p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0，格式见sample。</p>
<h2 id="Sample-Input-26"><a href="#Sample-Input-26" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>50 0 10 59 591 1 123 0 023 59 59</p>
<h2 id="Sample-Output-26"><a href="#Sample-Output-26" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Copy constructor test output :There was a call to the copy constructor : 0,0,0There was a call to the copy constructor : 1,2,3Test data output :00:00:0100:59:5901:01:0123:00:0023:59:59</p>
<h2 id="HINT-26"><a href="#HINT-26" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-26"><a href="#Append-Code-26" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1388&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
public:
    int h,m,s;
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh, int mm, int ss) : s(ss), m(mm), h(hh) &#123; &#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;cout &lt;&lt; &quot;There was a call to the copy constructor : &quot; &lt;&lt; h &lt;&lt; &quot;,&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    Time &amp;getTime()  
    &#123;  
        return *this;  
    &#125;  
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime()&#123;
        cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
    &#125;      
&#125;;
///////////////////////////////////
int main()
&#123;
    cout&lt;&lt;&quot;Copy constructor test output :&quot;&lt;&lt;endl;
    Time t;
    Time tt(t);
    Time ttt(1, 2, 3);
    Time tttt(ttt.getTime());
    cout&lt;&lt;&quot;\nTest data output :&quot;&lt;&lt;endl;

    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        if(i % 2 == 0)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.setTime(hour, minute, second).showTime();
        &#125;
        if(i % 2 == 1)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            Time tt(hour, minute, second);
            t.setTime(tt).showTime();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="28-时间类的错误数据处理"><a href="#28-时间类的错误数据处理" class="headerlink" title="28.时间类的错误数据处理"></a>28.时间类的错误数据处理</h3><blockquote>
<h2 id="Description-27"><a href="#Description-27" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\3. Time::Time(const T&amp;)拷贝构造方法。</p>
<p>\4. 成员读函数：</p>
<p>   Time::hour()  ：返回Time的小时数；</p>
<p>   Time::minute()：返回Time的分钟数；</p>
<p>   Time::second()：返回Time的秒数。</p>
<p>\5. 成员写函数：</p>
<p>   Time::hour(int)  ：传参修改Time的小时数；</p>
<p>   Time::minute(int)：传参修改Time的分钟数；</p>
<p>   Time::second(int)：传参修改Time的秒数。</p>
<p>\6. 对象整体读写方法：</p>
<p>   Time::setTime(int,int,int)方法：传递时分秒三个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::setTime(const T&amp;)方法：传递一个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::getTime()方法：返回对象自身的引用。其实，t.getTime()即t。</p>
<p>   仅在Time类中的Time::getTime()方法实在是多余，在组合或者继承关系时才会有机会用到。</p>
<p>\7. Time::inputTime()方法：按格式从标准输入读取数据修改Time对象的时分秒数值。该方法返回修改后的对象。</p>
<p>\8. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。如果对象不是合法的时间，则输出“Time error”。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。main()函数内容稍微繁复，仅为测试对象的各种调用情况。</p>
<h2 id="Input-27"><a href="#Input-27" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在int范围内。</p>
<h2 id="Output-27"><a href="#Output-27" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0。如果输入的时间不合法，则输出“Time error”。格式见sample。</p>
<h2 id="Sample-Input-27"><a href="#Sample-Input-27" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>60 0 10 59 591 1 6023 0 023 59 5924 1 0</p>
<h2 id="Sample-Output-27"><a href="#Sample-Output-27" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>00:00:0100:59:59Time error23:00:0023:59:59Time error</p>
<h2 id="HINT-27"><a href="#HINT-27" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-27"><a href="#Append-Code-27" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1389&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
public:
    int h,m,s;
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh, int mm, int ss) : s(ss), m(mm), h(hh) &#123; &#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;cout &lt;&lt; &quot;There was a call to the copy constructor : &quot; &lt;&lt; h &lt;&lt; &quot;,&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    Time &amp;getTime()  
    &#123;  
        return *this;  
    &#125;  
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;    
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime()&#123;
        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;
    &#125;    
    Time &amp;inputTime()&#123;
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s ;
        return *this;
    &#125;  
&#125;;
/////////////////////////////
int main()
&#123;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        if(i % 4 == 0)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            Time tt(hour, minute, second);
            tt.showTime();
        &#125;
        if(i % 4 == 1)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.setTime(hour, minute, second).showTime();
        &#125;
        if(i % 4 == 2)
            t.inputTime().showTime();
        if(i % 4 == 3)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.hour(hour);
            t.minute(minute);
            t.second(second);
            t.showTime();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="29-时间类的常量"><a href="#29-时间类的常量" class="headerlink" title="29.时间类的常量"></a>29.时间类的常量</h3><blockquote>
<h2 id="Description-28"><a href="#Description-28" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\3. Time::Time(const T&amp;)拷贝构造方法。</p>
<p>\4. 成员读函数：</p>
<p>   Time::hour()  ：返回Time的小时数；</p>
<p>   Time::minute()：返回Time的分钟数；</p>
<p>   Time::second()：返回Time的秒数。</p>
<p>\5. 成员写函数：</p>
<p>   Time::hour(int)  ：传参修改Time的小时数；</p>
<p>   Time::minute(int)：传参修改Time的分钟数；</p>
<p>   Time::second(int)：传参修改Time的秒数。</p>
<p>\6. 对象整体读写方法：</p>
<p>   Time::setTime(int,int,int)方法：传递时分秒三个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::setTime(const T&amp;)方法：传递一个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::getTime()方法：返回对象自身的引用。其实，t.getTime()即t。</p>
<p>   仅在Time类中的Time::getTime()方法实在是多余，在组合或者继承关系时才会有机会用到。</p>
<p>\7. Time::inputTime()方法：按格式从标准输入读取数据修改Time对象的时分秒数值。该方法返回修改后的对象。</p>
<p>\8. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。如果对象不是合法的时间，则输出“Time error”。</p>
<p>注意：为了保证Time类的常量对象能够正确的调用Time类的方法，那些不修改对象数据成员的函数都应该是常量成员函数，在返回对象自身的引用时也应返回常量引用。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。main()函数内容稍微繁复，仅为测试对象的各种调用情况。</p>
<h2 id="Input-28"><a href="#Input-28" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在int范围内。</p>
<h2 id="Output-28"><a href="#Output-28" class="headerlink" title="Output"></a>Output</h2><p>开始部分为由main()函数产生的固定输出，用于测试对象的某些方法的调用情况。输出“Test data output :”之后为测试数据对应的输出：</p>
<p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0。如果输入的时间不合法，则输出“Time error”。格式见sample。</p>
<h2 id="Sample-Input-28"><a href="#Sample-Input-28" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>60 0 10 59 591 1 6023 0 023 59 5924 1 0</p>
<h2 id="Sample-Output-28"><a href="#Sample-Output-28" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Constant test output :00:00:0001:02:03Time errorTest data output :00:00:0100:59:59Time error23:00:0023:59:59Time error</p>
<h2 id="HINT-28"><a href="#HINT-28" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-28"><a href="#Append-Code-28" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1390&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
private:
    int h,m,s;
public:
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh, int mm, int ss):h(hh),m(mm),s(ss)&#123; &#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;cout &lt;&lt; &quot;There was a call to the copy constructor : &quot; &lt;&lt; h &lt;&lt; &quot;,&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    const Time &amp;getTime()const  
    &#123;  
        return *this;  
    &#125;  
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;    
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime() const&#123;
        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;
    &#125;    
    Time &amp;inputTime()&#123; 
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s ;
        return *this;
    &#125;  
&#125;;

//////////////////////////////
int main()
&#123;
    cout&lt;&lt;&quot;Constant test output :&quot;&lt;&lt;endl;
    const Time c;
    const Time cc(1, 2, 3);
    const Time ccc(23, 60, 60);
    cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;c.hour()&lt;&lt;&quot;:&quot;;
    cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;c.minute()&lt;&lt;&quot;:&quot;;
    cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;c.second()&lt;&lt;endl;
    cc.getTime().showTime();
    ccc.showTime();

    cout&lt;&lt;&quot;\nTest data output :&quot;&lt;&lt;endl;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        if(i % 4 == 0)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            Time tt(hour, minute, second);
            tt.showTime();
        &#125;
        if(i % 4 == 1)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.setTime(hour, minute, second).showTime();
        &#125;
        if(i % 4 == 2)
            t.inputTime().showTime();
        if(i % 4 == 3)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.hour(hour);
            t.minute(minute);
            t.second(second);
            t.showTime();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="30-时间类的12小时制输出"><a href="#30-时间类的12小时制输出" class="headerlink" title="30.时间类的12小时制输出"></a>30.时间类的12小时制输出</h3><blockquote>
<h2 id="Description-29"><a href="#Description-29" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持24小时制和12小时制，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\3. Time::Time(const T&amp;)拷贝构造方法。</p>
<p>\4. 成员读函数：</p>
<p>   Time::hour()  ：返回Time的小时数；</p>
<p>   Time::minute()：返回Time的分钟数；</p>
<p>   Time::second()：返回Time的秒数。</p>
<p>\5. 成员写函数：</p>
<p>   Time::hour(int)  ：传参修改Time的小时数；</p>
<p>   Time::minute(int)：传参修改Time的分钟数；</p>
<p>   Time::second(int)：传参修改Time的秒数。</p>
<p>\6. 对象整体读写方法：</p>
<p>   Time::setTime(int,int,int)方法：传递时分秒三个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::setTime(const T&amp;)方法：传递一个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::getTime()方法：返回对象自身的引用。其实，t.getTime()即t。</p>
<p>   仅在Time类中的Time::getTime()方法实在是多余，在组合或者继承关系时才会有机会用到。</p>
<p>\7. Time::inputTime()方法：按格式从标准输入读取数据修改Time对象的时分秒数值。该方法返回修改后的对象。</p>
<p>\8. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。如果对象不是合法的时间，则输出“Time error”。</p>
<p>\9. Time::showTime12Hour()方法：输出12小时制的时间：上午输出“hh:mm:ss a.m.”、下午输出“hh:mm:ss p.m.”。如果对象不是合法的时间，则输出“Time error”。注意：该函数仅显示12小时制时间，并不修改对象的数据成员，对象依然存储24小时制时间。</p>
<p>12小时制以数字12、1、2、3、4、5、6、7、8、9、10、11依次序表示每个时段的。</p>
<p>24小时制的00:00～00:59，是12小时制的12:00 a.m.～12:59 a.m.；</p>
<p>24小时制的1:00～11:59是十二小时制的1:00 a.m.～11:59 a.m.。</p>
<p>24小时制的12:00～12:59，是12小时制的12:00 p.m.～12:59 p.m.；</p>
<p>24小时制的13:00～23:59是十二小时制的1:00 p.m.～11:59 p.m.。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。main()函数内容稍微繁复，仅为测试对象的各种调用情况。</p>
<h2 id="Input-29"><a href="#Input-29" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在int范围内。</p>
<h2 id="Output-29"><a href="#Output-29" class="headerlink" title="Output"></a>Output</h2><p>开始部分为由main()函数产生的固定输出，用于测试对象的某些方法的调用情况。输出“Test data output :”之后为测试数据对应的输出：</p>
<p>每组测试数据对应一组输出，奇数行的输入对应输出24小时制时间“hh:mm:ss”，偶数行的输入对应输出12小时制时间：上午输出“hh:mm:ss a.m.”、下午输出“hh:mm:ss p.m.”，不足两位的输出需要前面补0。如果输入的时间不合法，则输出“Time error”。格式见sample。</p>
<h2 id="Sample-Input-29"><a href="#Sample-Input-29" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>60 0 10 59 591 1 6023 0 023 59 5924 1 0</p>
<h2 id="Sample-Output-29"><a href="#Sample-Output-29" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Constant test output :11:59:58 a.m.12:00:01 p.m.11:59:5812:00:01Test data output :00:00:0112:59:59 a.m.Time error11:00:00 p.m.23:59:59Time error</p>
<h2 id="HINT-29"><a href="#HINT-29" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-29"><a href="#Append-Code-29" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1391&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
private:
    int h,m,s;
public:
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh, int mm, int ss):h(hh),m(mm),s(ss)&#123; &#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;cout &lt;&lt; &quot;There was a call to the copy constructor : &quot; &lt;&lt; h &lt;&lt; &quot;,&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    const Time &amp;getTime()const  
    &#123;  
        return *this;  
    &#125;  
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;    
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime() const&#123;
        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;
    &#125;    
    Time &amp;inputTime()&#123; 
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s ;
        return *this;
    &#125;  
    void showTime12Hour()const&#123;
        if(h &gt;= 1 &amp;&amp; h &lt; 12 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; &quot; a.m.&quot; &lt;&lt; endl;            
        else if(h &gt;= 0 &amp;&amp; h &lt; 1 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; &quot;12&quot; &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; &quot; a.m.&quot; &lt;&lt; endl;            
        else if(h &gt;= 12 &amp;&amp; h &lt; 13 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; &quot;12&quot; &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; &quot; p.m.&quot; &lt;&lt; endl;            
        else if(h &gt;= 13 &amp;&amp; h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h-12 &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; &quot; p.m.&quot; &lt;&lt; endl;            
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;            
    &#125;
&#125;;
/////////////////////////////
int main()
&#123;
    cout&lt;&lt;&quot;Constant test output :&quot;&lt;&lt;endl;
    const Time c(11, 59, 58);
    const Time cc(12, 0, 1);
    c.showTime12Hour();
    cc.showTime12Hour();
    c.showTime();
    cc.showTime();

    cout&lt;&lt;&quot;\nTest data output :&quot;&lt;&lt;endl;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        if(i % 4 == 0)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            Time tt(hour, minute, second);
            tt.showTime12Hour();
        &#125;
        if(i % 4 == 1)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.setTime(hour, minute, second).showTime();
        &#125;
        if(i % 4 == 2)
            t.inputTime().showTime12Hour();
        if(i % 4 == 3)
        &#123;
            int hour, minute, second;
            cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second;
            t.hour(hour);
            t.minute(minute);
            t.second(second);
            t.showTime();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="31-时间类的静态成员计数"><a href="#31-时间类的静态成员计数" class="headerlink" title="31.时间类的静态成员计数"></a>31.时间类的静态成员计数</h3><blockquote>
<h2 id="Description-30"><a href="#Description-30" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，用于时间处理的相关功能，支持以下操作：</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::Time(int,int,int)构造方法：传递时分秒的三个参数构造对象。</p>
<p>\3. Time::Time(const T&amp;)拷贝构造方法。</p>
<p>\4. 对象整体读写方法：</p>
<p>   Time::setTime(int,int,int)方法：传递时分秒三个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::setTime(const T&amp;)方法：传递一个参数修改Time对象的时分秒数。该方法返回修改后的对象。</p>
<p>   Time::getTime()方法：返回对象自身的引用。其实，t.getTime()即t。</p>
<p>   仅在Time类中的Time::getTime()方法实在是多余，在组合或者继承关系时才会有机会用到。</p>
<p>\5. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。如果对象不是合法的时间，则输出“Time error”。</p>
<p>\6. 静态成员方法：</p>
<p>   Time::getNumber()方法：返回程序中已创建的Time对象总数。</p>
<p>   Time::displayNumber()方法：输出程序中已创建的Time对象总数。</p>
<p>注意：在用Time对象传递参数时应传对象的引用而不是直接传对象，返回对象时同样返回引用，以免产生多余的对象拷贝。多余的拷贝构造会引起对象计数的错误。</p>
<p>你设计一个时间类Time，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。main()函数内容稍微繁复，仅为测试对象的各种调用情况。</p>
<h2 id="Input-30"><a href="#Input-30" class="headerlink" title="Input"></a>Input</h2><p>输入为多行，每行为一组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在int范围内。</p>
<h2 id="Output-30"><a href="#Output-30" class="headerlink" title="Output"></a>Output</h2><p>开始部分为由main()函数产生的固定输出，用于测试对象的某些方法的调用情况。输出“Test data output :”之后为测试数据对应的输出：</p>
<p>每组测试数据对应一组输出“hh:mm:ss”，不足两位的输出需要前面补0。如果输入的时间不合法，则输出“Time error”。格式见sample。</p>
<p>最后一行输出一个整数n，表示有n组测试数据输入。</p>
<h2 id="Sample-Input-30"><a href="#Sample-Input-30" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>0 0 10 59 591 1 6023 0 023 59 5924 1 0</p>
<h2 id="Sample-Output-30"><a href="#Sample-Output-30" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Static member test output :Now, There is 0 object of Time.Now, There is 1 object of Time.There was a call to the copy constructor : 0,0,0Now, There is 2 object of Time.Now, There is 3 object of Time.There was a call to the copy constructor : 1,2,3Now, There is 4 object of Time.Test data output :00:00:0100:59:59Time error23:00:0023:59:59Time error6</p>
<h2 id="HINT-30"><a href="#HINT-30" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-30"><a href="#Append-Code-30" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1392&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
private:
    int h,m,s;
    static int num;
public:
    Time():h(0),m(0),s(0)&#123;num++;&#125;
    Time(int hh, int mm, int ss):h(hh),m(mm),s(ss)&#123;num++;&#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;cout &lt;&lt; &quot;There was a call to the copy constructor : &quot; &lt;&lt; h &lt;&lt; &quot;,&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;num++;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    const Time &amp;getTime()const  
    &#123;  
        return *this;  
    &#125;  
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;    
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime() const&#123;
        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;
    &#125;    
    Time &amp;inputTime()&#123; 
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s ;
        return *this;
    &#125;  
    static int getNumber()&#123;return num;&#125;
    static void displayNumber()&#123;
        cout &lt;&lt; &quot;Now, There is &quot; &lt;&lt; num &lt;&lt; &quot; object of Time.&quot; &lt;&lt; endl;
    &#125;
&#125;;
int Time::num=0;
////////////////////
int main()
&#123;
    cout&lt;&lt;&quot;Static member test output :&quot;&lt;&lt;endl;
    Time::displayNumber();
    Time t;
    t.displayNumber();
    Time tt(t);
    tt.displayNumber();
    Time ttt(1, 2, 3);
    ttt.displayNumber();
    Time tttt(ttt.getTime());
    tttt.displayNumber();
    int non_cases = Time::getNumber();

    cout&lt;&lt;&quot;\nTest data output :&quot;&lt;&lt;endl;
    int hour, minute, second;
    while(cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second)
    &#123;
        Time t;
        t.setTime(hour, minute, second).showTime();
    &#125;
    cout&lt;&lt;t.getNumber() - non_cases&lt;&lt;endl;
&#125;</code></pre>
<blockquote>
<p>static–<a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777441.html" target="_blank" rel="noopener">http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777441.html</a></p>
<p> C++的static有两种用法：面向过程程序设计的static和面向对象程序设计中的static。前者应用于普通变量和函数，不涉及类；后者主要说明static在类中的作用。</p>
</blockquote>
<h3 id="32-时间类的加、减法赋值运算"><a href="#32-时间类的加、减法赋值运算" class="headerlink" title="32.时间类的加、减法赋值运算"></a>32.时间类的加、减法赋值运算</h3><blockquote>
<h2 id="Description-31"><a href="#Description-31" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，在类上重载以下运算符，使得main()函数能够正确运行。</p>
<p>\1. Time::Time()无参构造方法。</p>
<p>\2. Time::inputTime()方法：按格式从标准输入读取数据修改Time对象的时分秒数值。该方法返回修改后的对象。</p>
<p>\3. Time::showTime()方法：输出“hh:mm:ss”，不足两位的要前面补0。如果对象不是合法的时间，则输出“Time error”。</p>
<p>\4. 运算符</p>
<p>加法赋值运算符“+=”和减法赋值运算符“-=”：把一个整数m加到Time对象自身，并且仅对合法的时间操作，不会产生不合法的时间，比如：</p>
<p>若原时间对象为“00:00:00”，减去2后的对象为“23:59:58”;</p>
<p>若原时间对象为“23:59:59”，加上1后的对象为“00:00:00”;</p>
<p>若原时间对象为“24:60:60”，加减后的对象仍为“24:60:60”</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数</p>
<h2 id="Input-31"><a href="#Input-31" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组4个整数，前三个整数为：hh,mm,ss，分别表示时、分、秒，其值都在int范围内，最后一个整数为m。</p>
<h2 id="Output-31"><a href="#Output-31" class="headerlink" title="Output"></a>Output</h2><p>每个输入对应两行输出，分别为时间“hh,mm,ss”加上m秒和减去m秒后的值。错误的时间输出“Time error”</p>
<h2 id="Sample-Input-31"><a href="#Sample-Input-31" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>60 0 1 20 59 59 11 1 60 1023 0 0 6023 59 59 10024 1 0 3</p>
<h2 id="Sample-Output-31"><a href="#Sample-Output-31" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>00:00:0323:59:5901:00:0000:59:58Time errorTime error23:01:0022:59:0000:01:3923:58:19Time errorTime error</p>
<h2 id="HINT-31"><a href="#HINT-31" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<p>left      ：设置输出左对齐</p>
<p>right     ：设置输出优对齐</p>
<h2 id="Append-Code-31"><a href="#Append-Code-31" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1395&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time&#123;
private:
    int h,m,s;
    int k;
public:
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh, int mm, int ss):h(hh),m(mm),s(ss)&#123; &#125;
    Time(const Time&amp; t)&#123;h = t.h;m = t.m;s = t.s;&#125;
    Time &amp;setTime(int hh,int mm,int ss)  
    &#123;  
        h = hh;m = mm;s = ss;  
        return *this;  
    &#125;
    Time &amp;setTime(const Time &amp; t)  
    &#123;  
        h = t.hour();  
        m = t.minute();  
        s = t.second();  
        return *this;  
    &#125;  
    const Time &amp;getTime()const  
    &#123;  
        return *this;  
    &#125;  
    void hour(int hh)&#123;h=hh;&#125;
    void minute(int mm)&#123;m=mm;&#125;
    void second(int ss)&#123;s=ss;&#125;    
    int hour()const&#123;return h;&#125;  
    int minute()const&#123;return m;&#125;  
    int second()const&#123;return s;&#125;  
    void showTime() const&#123;
        if(h &lt; 24 &amp;&amp; m &lt; 60 &amp;&amp; s &lt; 60)
            cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; s &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Time error&quot; &lt;&lt; endl;
    &#125;    
    Time &amp;inputTime()&#123; 
        cin &gt;&gt; h &gt;&gt; m &gt;&gt; s ;
        return *this;
    &#125;  
    Time&amp; operator +=(int t)  
    &#123;  
        if(h*3600 + m*60 + s &gt;= 24*3600|| m&gt;59||s&gt;59||h&lt;0||s&lt;0||m&lt;0)  
            return *this;  
        else  
        &#123;  
            k = (h*3600 + m*60 + s+t)%(24*3600);  
            h = k/3600;  
            m = (k -h*3600)/60;  
            s = k-h*3600-m*60;  
            return *this;  
        &#125;  
    &#125;  
    Time&amp; operator -=(int t)  
    &#123;  
           if(h*3600 + m*60 + s &gt;= 24*3600|| m&gt;59||s&gt;59||h&lt;0||s&lt;0||m&lt;0)  
            return *this;  
        else  
        &#123;  
            k = (h*3600 + m*60 + s-t+24*3600)%(24*3600);  
            h = k/3600;  
            m = (k -h*3600)/60;  
            s = k-h*3600-m*60;  
            return *this;  
        &#125;  
    &#125;  
&#125;;
///////////////
int main()
&#123;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        Time t;
        t.inputTime();
        Time tt(t);
        int num;
        cin&gt;&gt;num;
        t += num;
        t.showTime();
        tt -= num;
        tt.showTime();
    &#125;
&#125;</code></pre>
<h3 id="33-时间类的流插入、提取和递增、递减运算"><a href="#33-时间类的流插入、提取和递增、递减运算" class="headerlink" title="33.时间类的流插入、提取和递增、递减运算"></a>33.时间类的流插入、提取和递增、递减运算</h3><blockquote>
<h2 id="Description-32"><a href="#Description-32" class="headerlink" title="Description"></a>Description</h2><p>封装一个时间类Time，在类上重载以下运算符，使得main()函数能够正确运行。</p>
<p>流插入操作符“&gt;&gt;”，按照输入格式从标准输入读取三个整数：hh,mm,ss，分别表示时、分、秒，其值在int范围内。</p>
<p>流提取操作符“&lt;&lt;”；按照“hh:mm:ss”输出Time类的对象，不合法的时间输出“error!!!”。</p>
<p>前置自增运算符“++”：把时间对象的秒数加1并返回。</p>
<p>前置自减运算符“–”：把时间对象的秒数减1并返回。</p>
<p>后置自增运算符“++”：把时间对象的秒数加1，返回原值。</p>
<p>后置自减运算符“–”：把时间对象的秒数减1，返回原值。</p>
<p>以上4个自增、自减仅对合法的时间操作，并且不会产生不合法的时间。比如：</p>
<p>若原时间对象为“00:00:00”，自减运算后的对象为“23:59:59”;</p>
<p>若原时间对象为“23:59:59”，自增运算后的对象为“00:00:00”;</p>
<p>若原时间对象为“24:60:60”，自增或自减运算后对象仍为“24:60:60”。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数</p>
<h2 id="Input-32"><a href="#Input-32" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，每组3个整数：hh,mm,ss，分别表示时、分、秒，其值都在int范围内。</p>
<h2 id="Output-32"><a href="#Output-32" class="headerlink" title="Output"></a>Output</h2><p>输出一张表：每列8个字符宽，两列之间有一个空格。</p>
<p>首先，输出一个表头：“++t      –t      t        t–      t++      t       ”，</p>
<p>其次，对应每组测试数据在一行内依次以下内容：</p>
<p>前置++、前置–、原值、后置–、后置++、原值。</p>
<p>若输入的日期合法，输出格式为“hh:mm:ss”，不足两位的输出需要前面补0。如果输入的时间不合法，则输出“error!!!”。格式见sample。</p>
<h2 id="Sample-Input-32"><a href="#Sample-Input-32" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>60 0 10 59 591 1 6023 0 023 59 5924 1 0</p>
<h2 id="Sample-Output-32"><a href="#Sample-Output-32" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>++t      –t      t        t–      t++      t       00:00:02 00:00:01 00:00:01 00:00:01 00:00:00 00:00:0101:00:00 00:59:59 00:59:59 00:59:59 00:59:58 00:59:59error!!! error!!! error!!! error!!! error!!! error!!!23:00:01 23:00:00 23:00:00 23:00:00 22:59:59 23:00:0000:00:00 23:59:59 23:59:59 23:59:59 23:59:58 23:59:59error!!! error!!! error!!! error!!! error!!! error!!!</p>
<h2 id="HINT-32"><a href="#HINT-32" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<p>left      ：设置输出左对齐</p>
<p>right     ：设置输出优对齐</p>
<h2 id="Append-Code-32"><a href="#Append-Code-32" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1396&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Time
&#123;
private:
    int h,m,s;
    int flag;
public:
    friend istream &amp; operator &gt;&gt; (istream &amp;is,Time &amp;t)
    &#123;
        is&gt;&gt;t.h&gt;&gt;t.m&gt;&gt;t.s;
        if(t.h&gt;23||t.h&lt;0||t.m&gt;59||t.m&lt;0||t.s&gt;59||t.s&lt;0)
            t.flag = 1;
        else t.flag = 0;
        return is;
    &#125;
    friend ostream &amp; operator &lt;&lt; (ostream &amp;os,const Time &amp;t)
    &#123;
        if(t.h*3600+t.m*60+t.s&gt;=24*3600||t.h&lt;0||t.s&lt;0||t.m&lt;0||t.m&gt;59||t.s&gt;59) &#123;os&lt;&lt;&quot;error!!!&quot;;&#125;
    else &#123;os&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;t.h&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;t.m&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;t.s;&#125;
    return os;
    &#125;
    Time &amp; operator ++ ()
    &#123;
        if(h*3600+m*60+s &gt;= 24*3600||h&lt;0||s&lt;0||m&lt;0||m&gt;59||s&gt;59)
            return *this;
        else
        &#123;
            flag=((h*3600+m*60+s)+1)%(24*3600);
            h=flag/3600;
            m=(flag-h*3600)/60;
            s=flag-h*3600-m*60;
            return *this;
        &#125;
    &#125;
    Time &amp;operator --()
    &#123;
         if(h*3600+m*60+s &gt;= 24*3600||h&lt;0||s&lt;0||m&lt;0||m&gt;59||s&gt;59)
            return *this;
        else
        &#123;
            flag=((h*3600+m*60+s)-1+24*3600)%(24*3600);
            h=flag/3600;
            m=(flag-h*3600)/60;
            s=flag-h*3600-m*60;
            return *this;
        &#125;
    &#125;
    Time operator ++ (int )
    &#123;
        Time t = (*this);
        if(h*3600+m*60+s &gt;= 24*3600||h&lt;0||s&lt;0||m&lt;0||m&gt;59||s&gt;59)
            return t;
        else
        &#123;
            flag=((h*3600+m*60+s)+1)%(24*3600);
            h=flag/3600;
            m=(flag-h*3600)/60;
            s=flag-h*3600-m*60;
            return t;
        &#125;
    &#125;
     Time operator --(int)
    &#123;
        Time t = (*this);
         if(h*3600+m*60+s &gt;= 24*3600||h&lt;0||s&lt;0||m&lt;0||m&gt;59||s&gt;59)
            return t;
        else
        &#123;
            flag=((h*3600+m*60+s)-1+24*3600)%(24*3600);
            h=flag/3600;
            m=(flag-h*3600)/60;
            s=flag-h*3600-m*60;
            return t;
        &#125;
    &#125;
&#125;;
int main()
&#123;
    Time t;
    int cases;
    cin&gt;&gt;cases;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;++t&quot;&lt;&lt;&quot; &quot;;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;--t&quot;&lt;&lt;&quot; &quot;;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;t&quot;&lt;&lt;&quot; &quot;;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;t--&quot;&lt;&lt;&quot; &quot;;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;t++&quot;&lt;&lt;&quot; &quot;;
    cout&lt;&lt;setw(8)&lt;&lt;left&lt;&lt;&quot;t&quot;&lt;&lt;right&lt;&lt;endl;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        cin&gt;&gt;t;
        cout&lt;&lt;(++t)&lt;&lt;&quot; &quot;;
        cout&lt;&lt;(--t)&lt;&lt;&quot; &quot;;
        cout&lt;&lt;t&lt;&lt;&quot; &quot;;
        cout&lt;&lt;t--&lt;&lt;&quot; &quot;;
        cout&lt;&lt;t++&lt;&lt;&quot; &quot;;
        cout&lt;&lt;t&lt;&lt;endl;
    &#125;
&#125;
</code></pre>
<h3 id="34-时间和日期类（I）"><a href="#34-时间和日期类（I）" class="headerlink" title="34.时间和日期类（I）"></a>34.时间和日期类（I）</h3><blockquote>
<h2 id="Description-33"><a href="#Description-33" class="headerlink" title="Description"></a>Description</h2><p>设计一个时间类和一个日期类，用于读取输入的数据，按格式输出日期和时间。</p>
<p>设计日期类Date需支持以下操作：</p>
<p>Date::Date(int,int,int)构造方法：传入的参数依次为年月日，用参数将日期初始化。</p>
<p>Date::showDate()按格式输出Date对象。</p>
<p>设计时间类Time需支持以下操作：</p>
<p>Time::Time(int,int,int)构造方法：传入的参数依次为时分秒，用参数将时间初始化。</p>
<p>Time::showTime()按格式输出Time对象。</p>
<p>-—————————————————————————-</p>
<p>你设计Date类和Time类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-33"><a href="#Input-33" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的输入每行为一组测试数据。每组测试数据的前3个整数是日期的年月日，后3个整数是时间的时分秒。</p>
<h2 id="Output-33"><a href="#Output-33" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一行输出。日期的输出格式为“yyyy-mm-dd”，时间的输出格式为“hh:mm:ss”，中间用一个空格分开。</p>
<h2 id="Sample-Input-33"><a href="#Sample-Input-33" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>31982 10 1 0 0 02000 2 28 23 59 592014 7 2 13 30 01</p>
<h2 id="Sample-Output-33"><a href="#Sample-Output-33" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1982-10-01 00:00:002000-02-28 23:59:592014-07-02 13:30:01</p>
<h2 id="HINT-33"><a href="#HINT-33" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-33"><a href="#Append-Code-33" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1574&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Date&#123;
public:
    int y,m,d;
    Date()&#123;&#125;
    Date(int yy,int mm,int dd):y(yy),m(mm),d(dd)&#123;&#125;
    void showDate()&#123;
        cout &lt;&lt; y &lt;&lt; &quot;-&quot; &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; m &lt;&lt; &quot;-&quot; &lt;&lt; d;
    &#125;
&#125;;
class Time&#123;
public:
    int h,m,s;
    Time()&#123;&#125;
    Time(int hh,int mm,int ss):h(hh),m(mm),s(ss)&#123;&#125;
    void showTime()&#123;
        cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; s &lt;&lt; endl;
    &#125;

&#125;;
/////////////////////////////
int main()
&#123;
    int cases;
    cin &gt;&gt; cases;
    for(int ca = 0; ca &lt; cases; ca++)
    &#123;
        int year, month, day;
        cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;
        Date date(year, month, day);
        date.showDate();
        cout &lt;&lt; &quot; &quot;;
        int hour, minute, second;
        cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second;
        Time time(hour, minute, second);
        time.showTime();
        cout &lt;&lt; endl;
    &#125;
&#125;</code></pre>
<h3 id="35-时间和日期类（II）"><a href="#35-时间和日期类（II）" class="headerlink" title="35.时间和日期类（II）"></a>35.时间和日期类（II）</h3><blockquote>
<h2 id="Description-34"><a href="#Description-34" class="headerlink" title="Description"></a>Description</h2><p>设计一个日期时间类，用于读取输入的数据，按格式输出日期和时间。</p>
<p>设计日期时间类DateTime由2个成员组成，分别是一个Date类对象和一个Time类对象；</p>
<p>设计DateTime类需支持以下操作：</p>
<p>DateTime::DateTime()无参构造方法：初始化为1年1月1日、0时0分0秒；</p>
<p>DateTime::DateTime(const Date&amp;,const Time&amp;)构造方法：依照参数传入的日期和时间初始化对象；</p>
<p>DateTime::DateTime(int,int,int,int,int,int)构造方法：依照参数（顺序为年月日、时分秒）初始化对象；</p>
<p>DateTime::showDateTime()方法：按格式输出DateTime对象；</p>
<p>DateTime::setDateTime(int,int,int,int,int,int)方法：依照参数（顺序为年月日、时分秒）修改对象的属性值；</p>
<p>DateTime类包含了两个类：Date类和Time类</p>
<p>设计日期类Date需支持以下操作：</p>
<p>Date::Date()无参构造方法：初始化为1年1月1日</p>
<p>Date::Date(int,int,int)构造方法：传入的参数依次为年月日，用参数将日期初始化。</p>
<p>Date::showDate()方法：按格式输出Date对象。</p>
<p>Date::setDate(int,int,int)方法：传入的参数依次为年月日，用参数修改对象的属性值</p>
<p>设计时间类Time需支持以下操作：</p>
<p>Time::Time()无参构造方法：初始化为0时0分0秒</p>
<p>Time::Time(int,int,int)构造方法：传入的参数依次为时分秒，用参数将时间初始化。</p>
<p>Time::showTime()方法：按格式输出Time对象。</p>
<p>Time::setTime(int,int,int)方法：传入的参数依次为时分秒，用参数修改对象的属性值</p>
<p>-—————————————————————————-</p>
<p>你设计DateTime类、Date类和Time类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-34"><a href="#Input-34" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的输入每行为一组测试数据。每组测试数据的前3个整数是日期的年月日，后3个整数是时间的时分秒。</p>
<h2 id="Output-34"><a href="#Output-34" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一行输出。日期的输出格式为“yyyy-mm-dd”，时间的输出格式为“hh:mm:ss”，中间用一个空格分开。</p>
<h2 id="Sample-Input-34"><a href="#Sample-Input-34" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>31982 10 1 0 0 02000 2 28 23 59 592014 7 2 13 30 01</p>
<h2 id="Sample-Output-34"><a href="#Sample-Output-34" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1000-10-10 01:01:011982-10-01 00:00:002000-02-28 23:59:592014-07-02 13:30:01</p>
<h2 id="HINT-34"><a href="#HINT-34" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-34"><a href="#Append-Code-34" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1575&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Date&#123;
public:
    friend class DateTime;
    int y,m,d;
    Date():y(1),m(1),d(1)&#123;&#125;
    Date(int yy,int mm,int dd):y(yy),m(mm),d(dd)&#123;&#125;
    void showDate()&#123;cout &lt;&lt; y &lt;&lt; &quot;-&quot; &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; m &lt;&lt; &quot;-&quot; &lt;&lt; d &lt;&lt; &quot; &quot;;&#125;
    Date&amp; setDate(int yy,int mm,int dd)&#123;y=yy;m=mm;d=dd;return *this;&#125;
&#125;;
class Time&#123;
public:
    friend class DateTime;
    int h,m,s;
    Time():h(0),m(0),s(0)&#123;&#125;
    Time(int hh,int mm,int ss):h(hh),m(mm),s(ss)&#123;&#125;
    void showTime()&#123;cout &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; h &lt;&lt; &quot;:&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; s ;&#125;
    Time&amp; setTime(int hh,int mm,int ss)&#123;h=hh;m=mm;s=ss;return *this;&#125;
&#125;;
class DateTime&#123;
public:
    friend class Date;
    friend class Time;
    Date D;
    Time T;
    DateTime():D(0,0,0),T(0,0,0)&#123;&#125;
    DateTime(const Date&amp; d,const Time&amp; t):D(d),T(t)&#123;&#125;
    DateTime(int a,int b,int c,int d,int e,int f):D(a,b,c),T(d,e,f)&#123;&#125;
    void showDateTime()&#123;D.showDate();T.showTime();&#125;
    DateTime&amp; setDateTime(int a,int b,int c,int d,int e,int f)&#123;D.y=a;D.m=b;D.d=c;T.h=d;T.m=e;T.s=f;return *this;&#125;
&#125;;
///////////////////
int main()
&#123;
    Date date(1000, 10, 10);
    Time time(1, 1, 1);
    DateTime date_time(date, time);
    date_time.showDateTime();
    cout &lt;&lt; endl;
    int cases, flag = 0;
    cin &gt;&gt; cases;
    for(int ca = 0; ca &lt; cases; ca++)
    &#123;
        int year, month, day;
        cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;
        int hour, minute, second;
        cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second;
        if(flag == 0)
        &#123;
            flag = 1;
            DateTime dt(year, month, day, hour, minute, second);
            dt.showDateTime();
        &#125;
        else if(flag == 1)
        &#123;
            flag == 0;
            date_time.setDateTime(year, month, day, hour, minute, second).showDateTime();
        &#125;
        cout &lt;&lt; endl;
    &#125;
&#125;</code></pre>
<h3 id="36-时间和日期类（III）"><a href="#36-时间和日期类（III）" class="headerlink" title="36.时间和日期类（III）"></a>36.时间和日期类（III）</h3><blockquote>
<h2 id="Description-35"><a href="#Description-35" class="headerlink" title="Description"></a>Description</h2><p>设计一个日期时间类，用于读取输入的数据，按格式输出日期和时间。</p>
<p>设计日期时间类DateTime由2个成员组成，分别是一个Date类对象和一个Time类对象；</p>
<p>设计DateTime类需支持以下操作：</p>
<p>DateTime::DateTime()无参构造方法：初始化为1年1月1日、0时0分0秒；</p>
<p>DateTime::DateTime(int,int,int,int,int,int)构造方法：依照参数（顺序为年月日、时分秒）初始化对象；</p>
<p>在上述两个DateTime类的构造函数中输出：“CREATE DateTime : (y, m, d, hh, mm, ss)”，其中y、m、d为初始化对象时的年月日值，h、m、s为初始化对象时的时分秒值。参见输出。</p>
<p>DateTime::DateTime(const Date&amp;,const Time&amp;)构造方法：依照参数传入的日期和时间初始化对象；</p>
<p>在这个DateTime类的构造函数中输出：“CREATE DateTime : (y, m, d) (hh, mm, ss)”，其中y、m、d为初始化对象时的年月日值，h、m、s为初始化对象时的时分秒值。参见输出。</p>
<p>DateTime::showDateTime()方法：按格式输出DateTime对象；</p>
<p>DateTime::setDateTime(int,int,int,int,int,int)方法：依照参数（顺序为年月日、时分秒）修改对象的属性值；</p>
<p>DateTime类包含了两个类：Date类和Time类</p>
<p>设计日期类Date需支持以下操作：</p>
<p>Date::Date()无参构造方法：初始化为1年1月1日</p>
<p>Date::Date(int,int,int)构造方法：传入的参数依次为年月日，用参数将日期初始化。</p>
<p>在Date类的构造函数中输出：“CREATE Date : (y, m, d)”，其中y、m、d为初始化对象时的年月日值。参见输出。</p>
<p>Date::showDate()方法：按格式输出Date对象。</p>
<p>Date::setDate(int,int,int)方法：传入的参数依次为年月日，用参数修改对象的属性值</p>
<p>设计时间类Time需支持以下操作：</p>
<p>Time::Time()无参构造方法：初始化为0时0分0秒</p>
<p>Time::Time(int,int,int)构造方法：传入的参数依次为时分秒，用参数将时间初始化。</p>
<p>在Time类的构造函数中输出：“CREATE Time : (h, m, s)”，其中h、m、s为初始化对象时的时分秒值。参见输出</p>
<p>Time::showTime()方法：按格式输出Time对象。</p>
<p>Time::setTime(int,int,int)方法：传入的参数依次为时分秒，用参数修改对象的属性值</p>
<p>-—————————————————————————-</p>
<p>你设计DateTime类、Date类和Time类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数</p>
<h2 id="Input-35"><a href="#Input-35" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的输入每行为一组测试数据。每组测试数据的前3个整数是日期的年月日，后3个整数是时间的时分秒。</p>
<h2 id="Output-35"><a href="#Output-35" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一行输出。日期的输出格式为“yyyy-mm-dd”，时间的输出格式为“hh:mm:ss”，中间用一个空格分开。</p>
<h2 id="Sample-Input-35"><a href="#Sample-Input-35" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>31982 10 1 0 0 02000 2 28 23 59 592014 7 2 13 30 01</p>
<h2 id="Sample-Output-35"><a href="#Sample-Output-35" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>CREATE Time : (0, 0, 0)CREATE Date : (1, 1, 1)CREATE DateTime : (1, 1, 1, 0, 0, 0)0001-01-01 00:00:001982-10-01 00:00:002000-02-28 23:59:592014-07-02 13:30:01</p>
<h2 id="HINT-35"><a href="#HINT-35" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-35"><a href="#Append-Code-35" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1576&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;iomanip&gt;  
using namespace std;  


class Time&#123;  
   private:  
      friend class DateTime;  
      int hh,mm,ss;  
   public:  
      Time():hh(0),mm(0),ss(0)&#123;  
          cout&lt;&lt;&quot;CREATE Time : (&quot;&lt;&lt;hh&lt;&lt;&quot;, &quot;&lt;&lt;mm&lt;&lt;&quot;, &quot;&lt;&lt;ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
      &#125;  
      Time(int a,int b,int c):hh(a),mm(b),ss(c)&#123;&#125;  
      Time &amp;setTime(int a,int b,int c)&#123;hh=a;mm=b;ss=c;return *this;&#125;  
      void showTime()&#123;  
        cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;hh&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;mm&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;ss;  
      &#125;  
      ~Time()&#123;&#125;  
&#125;;  

class Date&#123;  
   private:  
       friend class DateTime;  
       int year,month,day;  
   public:  
       Date():year(1),month(1),day(1)&#123;  
           cout&lt;&lt;&quot;CREATE Date : (&quot;&lt;&lt;year&lt;&lt;&quot;, &quot;&lt;&lt;month&lt;&lt;&quot;, &quot;&lt;&lt;day&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       Date(int a,int b,int c):year(a),month(b),day(c)&#123;&#125;  
       Date &amp;setDate(int a,int b,int c)&#123;year=a;month=b;day=c;return *this;&#125;  
       void showDate() &#123;  
           cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(4)&lt;&lt;year&lt;&lt;&quot;-&quot;&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;month&lt;&lt;&quot;-&quot;&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;day&lt;&lt;&quot; &quot;;  
       &#125;  
       ~Date()&#123;&#125;  
&#125;;  



class DateTime&#123;  
   private:  
       friend class Date;  
       friend class Time;  
       Time T;  
       Date D;  
       int year1,month1,day1,hh1,mm1,ss1;  
   public:  
       DateTime()&#123;  
         cout&lt;&lt;&quot;CREATE DateTime : (&quot;&lt;&lt;D.year&lt;&lt;&quot;, &quot;&lt;&lt;D.month&lt;&lt;&quot;, &quot;&lt;&lt;D.day&lt;&lt;&quot;, &quot;&lt;&lt;T.hh&lt;&lt;&quot;, &quot;&lt;&lt;T.mm&lt;&lt;&quot;, &quot;&lt;&lt;T.ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       DateTime(const Date&amp; d,const Time&amp; t):D(d),T(t)&#123;&#125;  
       DateTime(int a,int b,int c,int d,int e,int f):D(a,b,c),T(d,e,f)&#123;&#125;  
       void showDateTime()&#123;  
         D.showDate();  T.showTime();  
       &#125;  
       DateTime &amp;setDateTime(int a,int b,int c,int d,int e,int f)&#123;  
           D.setDate(a,b,c);T.setTime(d,e,f);return *this;  
       &#125;  
       ~DateTime()&#123;&#125;  
&#125;;  

int main()  
&#123;  
    DateTime date_time;  
    date_time.showDateTime();  
    cout &lt;&lt; endl;  
    int cases;  
    cin &gt;&gt; cases;  
    for(int ca = 0; ca &lt; cases; ca++)  
    &#123;  
        int year, month, day;  
        cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;  
        int hour, minute, second;  
        cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second;  
        date_time.setDateTime(year, month, day, hour, minute, second);  
        date_time.showDateTime();  
        cout &lt;&lt; endl;  
    &#125;  
&#125;  </code></pre>
<h3 id="37-时间和日期类（IV）"><a href="#37-时间和日期类（IV）" class="headerlink" title="37.时间和日期类（IV）"></a>37.时间和日期类（IV）</h3><blockquote>
<h2 id="Description-36"><a href="#Description-36" class="headerlink" title="Description"></a>Description</h2><p>设计一个日期时间类，用于读取输入的数据，按格式输出日期和时间。</p>
<p>设计日期时间类DateTime由2个成员组成，分别是一个Date类对象和一个Time类对象；</p>
<p>设计DateTime类需支持以下操作：</p>
<p>DateTime::DateTime()无参构造方法：初始化为1年1月1日、0时0分0秒；</p>
<p>DateTime::DateTime(int,int,int,int,int,int)构造方法：依照参数（顺序为年月日、时分秒）初始化对象；</p>
<p>在上述两个DateTime类的构造函数中输出：“CREATE DateTime : (y, m, d, hh, mm, ss)”，其中y、m、d为初始化对象时的年月日值，h、m、s为初始化对象时的时分秒值。参见输出。</p>
<p>DateTime::DateTime(const Date&amp;,const Time&amp;)构造方法：依照参数传入的日期和时间初始化对象；</p>
<p>在这个DateTime类的构造函数中输出：“CREATE DateTime : (y, m, d) (hh, mm, ss)”，其中y、m、d为初始化对象时的年月日值，h、m、s为初始化对象时的时分秒值。参见输出。</p>
<p>DateTime:DateTime(const DateTime&amp;)构造方法：拷贝构造函数，初始化对象。</p>
<p>在拷贝构造函数中输出：“COPY   DateTime : (y, m, d) (hh, mm, ss)”，其中y、m、d为初始化对象时的年月日值，h、m、s为初始化对象时的时分秒值。参见输出。</p>
<p>DateTime::showDateTime()方法：按格式输出DateTime对象；</p>
<p>DateTime::setDateTime(int,int,int,int,int,int)方法：依照参数（顺序为年月日、时分秒）修改对象的属性值；</p>
<p>编写DateTime类的读写函数：year()、month()、day()、hour()、minute()、second()。读写函数的参数、返回值参见main()函数。</p>
<p>DateTime类包含了两个类：Date类和Time类</p>
<p>设计日期类Date需支持以下操作：</p>
<p>Date::Date()无参构造方法：初始化为1年1月1日</p>
<p>Date::Date(int,int,int)构造方法：传入的参数依次为年月日，用参数将日期初始化。</p>
<p>在Date类的构造函数中输出：“CREATE Date : (y, m, d)”，其中y、m、d为初始化对象时的年月日值。参见输出。</p>
<p>Date::Date(const Date&amp;)构造方法：拷贝构造函数，初始化对象。</p>
<p>在拷贝构造函数中输出：“COPY   Date : (y, m, d)”，其中y、m、d为初始化对象时的年月日值。参见输出。</p>
<p>Date::showDate()方法：按格式输出Date对象。</p>
<p>Date::setDate(int,int,int)方法：传入的参数依次为年月日，用参数修改对象的属性值</p>
<p>设计时间类Time需支持以下操作：</p>
<p>Time::Time()无参构造方法：初始化为0时0分0秒</p>
<p>Time::Time(int,int,int)构造方法：传入的参数依次为时分秒，用参数将时间初始化。</p>
<p>在Time类的构造函数中输出：“CREATE Time : (h, m, s)”，其中h、m、s为初始化对象时的时分秒值。参见输出</p>
<p>Time::Time(const Time&amp;)构造方法：拷贝构造函数，初始化对象。</p>
<p>在拷贝构造函数中输出：“COPY   Time : (h, m, s)”，其中h、m、s为初始化对象时的时分秒值。参见输出</p>
<p>Time::showTime()方法：按格式输出Time对象。</p>
<p>Time::setTime(int,int,int)方法：传入的参数依次为时分秒，用参数修改对象的属性值</p>
<p>-—————————————————————————-</p>
<p>你设计DateTime类、Date类和Time类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-36"><a href="#Input-36" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的输入每行为一组测试数据。每组测试数据的前3个整数是日期的年月日，后3个整数是时间的时分秒。</p>
<h2 id="Output-36"><a href="#Output-36" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一行输出。日期的输出格式为“yyyy-mm-dd”，时间的输出格式为“hh:mm:ss”，中间用一个空格分开。</p>
<h2 id="Sample-Input-36"><a href="#Sample-Input-36" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>31982 10 1 0 0 02000 2 28 23 59 592014 7 2 13 30 01</p>
<h2 id="Sample-Output-36"><a href="#Sample-Output-36" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>CREATE Date : (1000, 10, 10)COPY   Date : (1000, 10, 10)CREATE Time : (1, 1, 1)COPY   Time : (1, 1, 1)COPY   Time : (1, 1, 1)COPY   Date : (1000, 10, 10)CREATE DateTime : (1000, 10, 10) (1, 1, 1)COPY   Time : (1, 1, 1)COPY   Date : (1000, 10, 10)COPY   DateTime : (1000, 10, 10) (1, 1, 1)DateTime : 1000 10 10 1 1 11982-10-01 00:00:002000-02-28 23:59:592014-07-02 13:30:01</p>
<h2 id="HINT-36"><a href="#HINT-36" class="headerlink" title="HINT"></a>HINT</h2><p>输出格式用头文件<iomanip>中流操作算子：</p>
<p>setw(w)   ：设置数据的输出宽度为w个字符</p>
<p>setfill(c)：设置用字符c作为填充字符</p>
<h2 id="Append-Code-36"><a href="#Append-Code-36" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1577&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;iomanip&gt;  
using namespace std;  


class Time&#123;  
   private:  
      friend class DateTime;  
      int hh,mm,ss;  
   public:  
      Time():hh(0),mm(0),ss(0)&#123;  
          cout&lt;&lt;&quot;CREATE Time : (&quot;&lt;&lt;hh&lt;&lt;&quot;, &quot;&lt;&lt;mm&lt;&lt;&quot;, &quot;&lt;&lt;ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
      &#125;  
      Time(int a,int b,int c):hh(a),mm(b),ss(c)&#123;  
           cout&lt;&lt;&quot;CREATE Time : (&quot;&lt;&lt;hh&lt;&lt;&quot;, &quot;&lt;&lt;mm&lt;&lt;&quot;, &quot;&lt;&lt;ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
      &#125;  
      Time(const Time &amp;p):hh(p.hh),mm(p.mm),ss(p.ss)&#123;  
          cout&lt;&lt;&quot;COPY   Time : (&quot;&lt;&lt;hh&lt;&lt;&quot;, &quot;&lt;&lt;mm&lt;&lt;&quot;, &quot;&lt;&lt;ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
      &#125;  
      Time &amp;setTime(int a,int b,int c)&#123;hh=a;mm=b;ss=c;return *this;&#125;  
      void showTime()&#123;  
        cout&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;hh&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;mm&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;ss;  
      &#125;  
      ~Time()&#123;&#125;  
&#125;;  

class Date&#123;  
   private:  
       friend class DateTime;  
       int year,month,day;  
   public:  
       Date():year(1),month(1),day(1)&#123;  
           cout&lt;&lt;&quot;CREATE Date : (&quot;&lt;&lt;year&lt;&lt;&quot;, &quot;&lt;&lt;month&lt;&lt;&quot;, &quot;&lt;&lt;day&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       Date(const Date &amp;p):year(p.year),month(p.month),day(p.day)&#123;  

          cout&lt;&lt;&quot;COPY   Date : (&quot;&lt;&lt;year&lt;&lt;&quot;, &quot;&lt;&lt;month&lt;&lt;&quot;, &quot;&lt;&lt;day&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
      &#125;  
       Date(int a,int b,int c):year(a),month(b),day(c)&#123;  
          cout&lt;&lt;&quot;CREATE Date : (&quot;&lt;&lt;year&lt;&lt;&quot;, &quot;&lt;&lt;month&lt;&lt;&quot;, &quot;&lt;&lt;day&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       Date &amp;setDate(int a,int b,int c)&#123;year=a;month=b;day=c;return *this;&#125;  
       void showDate() &#123;  
           cout&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(4)&lt;&lt;year&lt;&lt;&quot;-&quot;&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;month&lt;&lt;&quot;-&quot;&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;day&lt;&lt;&quot; &quot;;  
       &#125;  
       ~Date()&#123;&#125;  
&#125;;  



class DateTime&#123;  
   private:  
       friend class Date;  
       friend class Time;  
       Time T;  
       Date D;  
       int year1,month1,day1,hh1,mm1,ss1;  
   public:  
       DateTime()&#123;  
         cout&lt;&lt;&quot;CREATE DateTime : (&quot;&lt;&lt;D.year&lt;&lt;&quot;, &quot;&lt;&lt;D.month&lt;&lt;&quot;, &quot;&lt;&lt;D.day&lt;&lt;&quot;, &quot;&lt;&lt;T.hh&lt;&lt;&quot;, &quot;&lt;&lt;T.mm&lt;&lt;&quot;, &quot;&lt;&lt;T.ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       DateTime(const Date&amp; d,const Time&amp; t):D(d),T(t)&#123;  
         cout&lt;&lt;&quot;CREATE DateTime : (&quot;&lt;&lt;D.year&lt;&lt;&quot;, &quot;&lt;&lt;D.month&lt;&lt;&quot;, &quot;&lt;&lt;D.day&lt;&lt;&quot;) (&quot;&lt;&lt;T.hh&lt;&lt;&quot;, &quot;&lt;&lt;T.mm&lt;&lt;&quot;, &quot;&lt;&lt;T.ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       DateTime(const DateTime&amp; p):T(p.T),D(p.D)&#123;  
        cout&lt;&lt;&quot;COPY   DateTime : (&quot;&lt;&lt;D.year&lt;&lt;&quot;, &quot;&lt;&lt;D.month&lt;&lt;&quot;, &quot;&lt;&lt;D.day&lt;&lt;&quot;) (&quot;&lt;&lt;T.hh&lt;&lt;&quot;, &quot;&lt;&lt;T.mm&lt;&lt;&quot;, &quot;&lt;&lt;T.ss&lt;&lt;&quot;)&quot;&lt;&lt;endl;  
       &#125;  
       DateTime(int a,int b,int c,int d,int e,int f):D(a,b,c),T(d,e,f)&#123;  
       &#125;  
       int const year(int year1)&#123;D.year=year1;&#125;  
       int const year() const &#123;return D.year;&#125;  
       int const month(int month1)&#123;D.month=month1;&#125;  
       int const month() const&#123;return D.month;&#125;  
       int const day(int day1)&#123;D.day=day1;&#125;  
       int const day() const&#123;return D.day;&#125;  
       int const hour(int hh1)&#123;T.hh=hh1;&#125;  
       int const hour() const&#123;return T.hh;&#125;  
       int const minute(int mm1)&#123;T.mm=mm1;&#125;  
       int const minute() const&#123;return T.mm;&#125;  
       int const second(int ss1)&#123;T.ss=ss1;&#125;  
       int const second() const&#123;return T.ss;&#125;  
       void showDateTime()&#123;  
         D.showDate();  T.showTime();  
       &#125;  
       DateTime &amp;setDateTime(int a,int b,int c,int d,int e,int f)&#123;  
           D.setDate(a,b,c);T.setTime(d,e,f);return *this;  
       &#125;  
       ~DateTime()&#123;&#125;  
&#125;;  

int main()  
&#123;  
    const Date date(1000, 10, 10), dt(date);  
    const Time time(1, 1, 1), tm(time);  
    DateTime date_time(dt, tm);  
    const DateTime cnt(date_time);  
    cout &lt;&lt; &quot;DateTime : &quot; &lt;&lt; cnt.year() &lt;&lt; &quot; &quot; &lt;&lt; cnt.month() &lt;&lt; &quot; &quot; &lt;&lt; cnt.day();  
    cout &lt;&lt; &quot; &quot; &lt;&lt; cnt.hour() &lt;&lt; &quot; &quot; &lt;&lt; cnt.minute() &lt;&lt; &quot; &quot; &lt;&lt; cnt.second();  
    cout &lt;&lt; endl;  
    int cases;  
    cin &gt;&gt; cases;  
    for(int ca = 0; ca &lt; cases; ca++)  
    &#123;  
        int year, month, day;  
        cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;  
        int hour, minute, second;  
        cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second;  
        date_time.year(year);  
        date_time.month(month);  
        date_time.day(day);  
        date_time.hour(hour);  
        date_time.minute(minute);  
        date_time.second(second);  
        date_time.showDateTime();  
        cout &lt;&lt; endl;  
    &#125;  
&#125;  </code></pre>
<h3 id="38-STL——灵活的线性表"><a href="#38-STL——灵活的线性表" class="headerlink" title="38.STL——灵活的线性表"></a>38.STL——灵活的线性表</h3><blockquote>
<h2 id="Description-37"><a href="#Description-37" class="headerlink" title="Description"></a>Description</h2><p>数组和链表是我们熟知的两种线性结构，但是它们不够灵活（不能同时实现直接插入、删除和访问操作），给你若干种操作，你能通过一种灵活的容器，实现它们的功能吗？</p>
<p>操作1：Build a b （产生一个大小为a的线性表，其值全部赋为b，每组样例仅出现一次，在起始行）</p>
<p>操作2：Modify a b （将线性表的第a个元素的值设为b）</p>
<p>操作3：Insert a b c （在线性表的第a个位置插入第b到第c个位置的所有元素）</p>
<p>操作4：Erase a b（删除线性表第a到第b个位置的所有元素）</p>
<p>操作5：Print a b （输出线性表的第a到第b个元素）</p>
<p>程序在执行操作5的时候要输出结果，格式如“[1]:3 [2]:4 [3]:5”（[]内为线性表的位置，“:”后面为元素的值，不带引号，每组输出占一行）</p>
<h2 id="Input-37"><a href="#Input-37" class="headerlink" title="Input"></a>Input</h2><p>输入有多行，对应5个操作，以EOF结束</p>
<h2 id="Output-37"><a href="#Output-37" class="headerlink" title="Output"></a>Output</h2><p>见Sample</p>
<h2 id="Sample-Input-37"><a href="#Sample-Input-37" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>Build 10 1Modify 2 2Insert 3 1 2Modify 6 4Erase 3 5Print 1 8</p>
<h2 id="Sample-Output-37"><a href="#Sample-Output-37" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>[1]:1 [2]:2 [3]:4 [4]:1 [5]:1 [6]:1 [7]:1 [8]:1</p>
<h2 id="HINT-37"><a href="#HINT-37" class="headerlink" title="HINT"></a>HINT</h2><p><a href="">﻿</a>使用vector可以很容易解决</p>
<h2 id="Append-Code-37"><a href="#Append-Code-37" class="headerlink" title="Append Code"></a>Append Code</h2></blockquote>
<pre><code>#include &lt;iostream&gt;  
#include &lt;vector&gt;  
#include &lt;string&gt;  
using namespace std;  
int main()  
&#123;  
   string l;  
   int a,b,c;  
   vector&lt;int&gt; s;  
   while(cin&gt;&gt;l)&#123;  
    if(l==&quot;Build&quot;)&#123;cin&gt;&gt;a&gt;&gt;b;s.assign(a,b);&#125;  
    else if(l==&quot;Modify&quot;)&#123;cin&gt;&gt;a&gt;&gt;b;s[a-1]=b;&#125;  
    else if(l==&quot;Insert&quot;)&#123;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;s.insert(s.begin()+a-1,s.begin()+b-1,s.begin()+c);&#125;  
    else if(l==&quot;Erase&quot;)&#123;cin&gt;&gt;a&gt;&gt;b;s.erase(s.begin()+a-1,s.begin()+b);&#125;  
    else if(l==&quot;Print&quot;)&#123;  
        cin&gt;&gt;a&gt;&gt;b;  
        int i;  
        for(i=a-1;i&lt;b;i++)  
        &#123;  
            if(i!=b-1)  
                cout&lt;&lt;&quot;[&quot;&lt;&lt;i+1&lt;&lt;&quot;]&quot;&lt;&lt;&quot;:&quot;&lt;&lt;s[i]&lt;&lt;&quot; &quot;;  
            else  
                cout&lt;&lt;&quot;[&quot;&lt;&lt;i+1&lt;&lt;&quot;]&quot;&lt;&lt;&quot;:&quot;&lt;&lt;s[i]&lt;&lt;endl;  
        &#125;  

    &#125;  
   &#125;  
   return 0;  
&#125;  </code></pre>
<blockquote>
<p>STL中vector容器用法</p>
<p><a href="http://www.cnblogs.com/ziyi--caolu/archive/2013/07/04/3170928.html" target="_blank" rel="noopener">http://www.cnblogs.com/ziyi--caolu/archive/2013/07/04/3170928.html</a></p>
<p><a href="http://www.cnblogs.com/zhonghuasong/p/5975979.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhonghuasong/p/5975979.html</a></p>
<p><a href="http://blog.csdn.net/xlm289348/article/details/8166820" target="_blank" rel="noopener">http://blog.csdn.net/xlm289348/article/details/8166820</a></p>
<p><a href="http://blog.csdn.net/liuweiyuxiang/article/details/52735561" target="_blank" rel="noopener">http://blog.csdn.net/liuweiyuxiang/article/details/52735561</a></p>
<blockquote>
<p><strong>3. vector基本操作</strong></p>
<p>(1). 容量</p>
<ul>
<li>向量大小： vec.size();</li>
<li>向量最大容量： vec.max_size();</li>
<li>更改向量大小： vec.resize();</li>
<li>向量真实大小： vec.capacity();</li>
<li>向量判空： vec.empty();</li>
<li>减少向量大小到满足元素所占存储空间的大小： vec.shrink_to_fit(); //<a href="http://www.cplusplus.com/reference/vector/vector/shrink_to_fit/" target="_blank" rel="noopener">shrink_to_fit</a></li>
</ul>
<p>(2). 修改</p>
<ul>
<li>多个元素赋值： vec.assign(); //类似于初始化时用数组进行赋值</li>
<li>末尾添加元素： vec.push_back();</li>
<li>末尾删除元素： vec.pop_back();</li>
<li>任意位置插入元素： vec.insert();</li>
<li>任意位置删除元素： vec.erase();</li>
<li>交换两个向量的元素： vec.swap();</li>
<li>清空向量元素： vec.clear();</li>
</ul>
<p>(3)迭代器</p>
<ul>
<li>开始指针：vec.begin();</li>
<li>末尾指针：vec.end(); //指向最后一个元素的下一个位置</li>
<li>指向常量的开始指针： vec.cbegin(); //意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</li>
<li>指向常量的末尾指针： vec.cend();</li>
</ul>
<p>(4)元素的访问</p>
<ul>
<li>下标访问： vec[1]; //并不会检查是否越界</li>
<li>at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常</li>
<li>访问第一个元素： vec.front();</li>
<li>访问最后一个元素： vec.back();</li>
<li>返回一个指针： int* p = vec.data(); //可行的原因在于vector在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是C++11的特性。</li>
</ul>
</blockquote>
</blockquote>
<h3 id="39-立体空间中的点（I）"><a href="#39-立体空间中的点（I）" class="headerlink" title="39.立体空间中的点（I）"></a>39.立体空间中的点（I）</h3><blockquote>
<h2 id="Description-38"><a href="#Description-38" class="headerlink" title="Description"></a>Description</h2><p>设计一个平面上的点Point类和3维的点Point_3D类，满足Point_3D类继承自Point类，用于读取输入的数据，输出所构造的两种点的坐标。</p>
<p>设计Point类需支持一下操作：</p>
<p>Point::Point()无参构造。</p>
<p>Point::Point(double,double)两个坐标参数构造。</p>
<p>Point::showPoint()按格式输出Point对象</p>
<p>设计Point_3D类需支持一下操作：</p>
<p>Point_3D::Point_3D()无参构造。</p>
<p>Point_3D::Point_3D(double,double,double)三个坐标参数构造。</p>
<p>Point_3D::showPoint()按格式输出Point_3D对象。</p>
<p>-—————————————————————————-</p>
<p>你设计Point类和Point_3D类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-38"><a href="#Input-38" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，后面的输入每行为一组测试数据。每组测试数据的第一行是一个整数m，m有两种取值：2、3；m为2时，后面有两个浮点数x、y，表示一个平面上的点的坐标(x,y)；m为3时后面有3个浮点数x、y、z，表示一个3维的点的坐标(x,y,z)。</p>
<h2 id="Output-38"><a href="#Output-38" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应一行输出。</p>
<p>若输入为平面上的点，则输出：“2D Point (x,y)”，x和y为输入的坐标值。</p>
<p>若输入为3维的点，则输出：“3D Point (x,y,y)”，x、y和z为输入的坐标值。</p>
<h2 id="Sample-Input-38"><a href="#Sample-Input-38" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>53 1 2 33 0 0 02 -1 13 -1 -1 -12 0 0</p>
<h2 id="Sample-Output-38"><a href="#Sample-Output-38" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3D Point (1,2,3)3D Point (0,0,0)2D Point (-1,1)3D Point (-1,-1,-1)2D Point (0,0)</p>
<h2 id="HINT-38"><a href="#HINT-38" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-38"><a href="#Append-Code-38" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1571&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point&#123;
public:
    double a,b;
    Point()&#123;&#125;
    Point(double aa,double bb):a(aa),b(bb)&#123;&#125;
    void showPoint()&#123;cout &lt;&lt; &quot;2D Point (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
class Point_3D:public Point&#123;
public:
    double c;
    Point_3D()&#123;&#125;
    Point_3D(double aa,double bb,double cc):Point(aa,bb),c(cc)&#123;&#125;
    void showPoint()&#123;cout &lt;&lt; &quot;2D Point (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
////////////////////
int main()
&#123;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; i++)
    &#123;
        double x, y, z;
        int point_type;
        cin&gt;&gt;point_type;
        if(point_type == 2)
        &#123;
            cin&gt;&gt;x&gt;&gt;y;
            Point p(x, y);
            p.showPoint();
        &#125;
        if(point_type == 3)
        &#123;
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
            Point_3D p(x, y, z);
            p.showPoint();
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>C++继承的概念及语法</p>
<p><a href="http://www.weixueyuan.net/view/6358.html" target="_blank" rel="noopener">http://www.weixueyuan.net/view/6358.html</a></p>
</blockquote>
<h3 id="40-立体空间中的点（II）"><a href="#40-立体空间中的点（II）" class="headerlink" title="40.立体空间中的点（II）"></a>40.立体空间中的点（II）</h3><blockquote>
<h2 id="Description-39"><a href="#Description-39" class="headerlink" title="Description"></a>Description</h2><p>设计一个平面上的点Point类和3维的点Point_3D类，满足Point_3D类继承自Point类，用于读取输入的数据，输出所构造的两种点的坐标。并统计输入的两种点的个数。</p>
<p>设计Point类需支持一下操作：</p>
<p>Point::Point()无参构造。</p>
<p>Point::Point(double,double)两个坐标参数构造。</p>
<p>Point::x()返回x坐标</p>
<p>Point::y()返回y坐标</p>
<p>Point::x(int)修改x坐标并返回</p>
<p>Point::y(int)修改y坐标并返回</p>
<p>Point::showPoint()按格式输出Point对象</p>
<p>Point::showNumber()返回Point对象总数的静态函数</p>
<p>设计Point_3D类需支持一下操作：</p>
<p>Point_3D::Point_3D()无参构造。</p>
<p>Point_3D::Point_3D(double,double,double)三个坐标参数构造。</p>
<p>Point_3D::z()返回z坐标。</p>
<p>Point_3D::z(int)修改z坐标并返回。</p>
<p>Point_3D::showPoint()按格式输出Point_3D对象。</p>
<p>Point_3D::setPoint(double,double,double)根据三个坐标参数修改Point_3D对象的坐标。</p>
<p>Point_3D::showNumber()返回Point_3D对象总数的静态函数。</p>
<p>-—————————————————————————-</p>
<p>你设计Point类和Point_3D类，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-39"><a href="#Input-39" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据，后面的输入每行为一组测试数据。每组测试数据的第一行是一个整数m，m有两种取值：2、3；m为2时，后面有两个浮点数x、y，表示一个平面上的点的坐标(x,y)；m为3时后面有3个浮点数x、y、z，表示一个3维的点的坐标(x,y,z)。</p>
<h2 id="Output-39"><a href="#Output-39" class="headerlink" title="Output"></a>Output</h2><p>开始部分为由main()函数产生的固定输出，用于测试对象的某些方法的调用情况。输出“Test data output :”之后为测试数据对应的输出：</p>
<p>每组测试数据对应一行输出。</p>
<p>若输入为平面上的点，则输出：“2D Point (x,y)”，x和y为输入的坐标值。</p>
<p>若输入为3维的点，则输出：“3D Point (x,y,y)”，x、y和z为输入的坐标值。</p>
<p>最后，分别输出总共输入的平面上的点数和3维的点数。</p>
<h2 id="Sample-Input-39"><a href="#Sample-Input-39" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>53 1 2 33 0 0 02 -1 13 -1 -1 -12 0 0</p>
<h2 id="Sample-Output-39"><a href="#Sample-Output-39" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Invariable test output :3D Point (-100,0,100)Point (0,100,100)Test data output :3D Point (1,2,3)3D Point (0,0,0)2D Point (-1,1)3D Point (-1,-1,-1)2D Point (0,0)Number of 2D Points : 2Number of 3D Points : 3</p>
<h2 id="HINT-39"><a href="#HINT-39" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-39"><a href="#Append-Code-39" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1393&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
class Point&#123;
public:
    static int num;
    double a,b;
    Point()&#123;&#125;
    Point(double aa,double bb):a(aa),b(bb)&#123;num++;&#125;
    void showPoint()&#123;cout &lt;&lt; &quot;2D Point (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    double x()&#123;return a;&#125;
    double y()&#123;return b;&#125;
    double x(double xx)&#123;a=xx;return a;&#125;
    double y(double yy)&#123;b=yy;return b;&#125;
    static int showNumber()&#123;return num+1;&#125;
&#125;;
class Point_3D:public Point&#123;
public:
    static int numm;
    double c;
    Point_3D()&#123;&#125;
    Point_3D(double aa,double bb,double cc):Point(aa,bb),c(cc)&#123;numm++;&#125;
    double z()&#123;return c;&#125;
    double z(double zz)&#123;c=zz;return c;&#125;
    static int showNumber()&#123;return numm+1;&#125;
    void setPoint(double aa,double bb,double cc)&#123;a=aa;b=bb;c=cc;&#125;
    void showPoint()&#123;cout &lt;&lt; &quot;2D Point (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
&#125;;
int Point::num = 0;
int Point_3D::numm = 0;
////////////////////
int main()
&#123;
    cout&lt;&lt;&quot;Invariable test output :&quot;&lt;&lt;endl;
    Point_3D p3d;
    p3d.setPoint(-100, 0, 100);
    p3d.showPoint();
    p3d.x(0);
    p3d.y(100);
    cout&lt;&lt;&quot;Point (&quot;&lt;&lt;p3d.x()&lt;&lt;&quot;,&quot;&lt;&lt;p3d.y()&lt;&lt;&quot;,&quot;&lt;&lt;p3d.z()&lt;&lt;&quot;)&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;\nTest data output :&quot;&lt;&lt;endl;
    int cases;
    cin&gt;&gt;cases;
    for(int i = 1; i &lt;= cases; i++)
    &#123;
        double x, y, z;
        int point_type;
        cin&gt;&gt;point_type;
        if(point_type == 2)
        &#123;
            cin&gt;&gt;x&gt;&gt;y;
            Point p(x, y);
            p.showPoint();
        &#125;
        if(point_type == 3)
        &#123;
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
            Point_3D p(x, y, z);
            p.showPoint();
        &#125;
    &#125;
    cout&lt;&lt;&quot;Number of 2D Points : &quot;&lt;&lt;Point::showNumber() - Point_3D::showNumber()&lt;&lt;endl;
    cout&lt;&lt;&quot;Number of 3D Points : &quot;&lt;&lt;Point_3D::showNumber() - 1&lt;&lt;endl;
&#125;</code></pre>
<h3 id="41-正方形、长方形、立方体"><a href="#41-正方形、长方形、立方体" class="headerlink" title="41.正方形、长方形、立方体"></a>41.正方形、长方形、立方体</h3><blockquote>
<h2 id="Description-40"><a href="#Description-40" class="headerlink" title="Description"></a>Description</h2><p>给出正方形（Square）、长方形（Rectangle）、立方体（Cuboid）的边长，求周长、面积、体积。</p>
<p>Square类只需存一条边长，构造函数产生一条输出，有边长、周长、面积的函数。</p>
<p>Rectangle类需存长和宽，若从Square类派生而来，因此只需增加一条边，构造函数产生一条输出，有长、宽、周长、面积的函数。</p>
<p>Cuboid类需存长宽高，若从Rectangle类派生而来，因此也只增加一条边，构造函数产生一条输出，有长、宽、高、周长、面积、体积的函数。它的周长定义为所有棱长之和。</p>
<p>-—————————————————————————-</p>
<p>请仔细阅读append.cc代码，并设计好正方形、长方形、立方体派生关系，使main()函数能够运行并得到正确的输出。</p>
<h2 id="Input-40"><a href="#Input-40" class="headerlink" title="Input"></a>Input</h2><p>输入分为三部分，每一部分都已一个整数n开始，表示后面有n组测试数据。</p>
<p>在第一部分测试数据中，每组是一个整数，表示正方形的边长。</p>
<p>在第二部分测试数据中，每组是两个整数，表示长方形的长和宽。</p>
<p>在第三部分测试数据中，每组是三个整数， 表示立方体的长和宽。</p>
<h2 id="Output-40"><a href="#Output-40" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应的输出为两部分，前面是构造函数的输出，最后是输出图形的信息，包括长宽高、周长、面积、体积等信息，格式见sample；</p>
<h2 id="Sample-Input-40"><a href="#Sample-Input-40" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1413 413 4 6</p>
<h2 id="Sample-Output-40"><a href="#Sample-Output-40" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Construct Square (4)A Square length 4, Perimeter 16, Area 16=========================Construct Square (3)Construct Rectangle (3, 4)A Rectangle length 3, width 4, Perimeter 14, Area 12=========================Construct Square (3)Construct Rectangle (3, 4)Construct Cuboid (3, 4, 6)A Cuboid length 3, width 4, height 6, Perimeter 52, Area 108, Volume 72</p>
<h2 id="HINT-40"><a href="#HINT-40" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-40"><a href="#Append-Code-40" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=0&pid=1678&getkey=" target="_blank" rel="noopener">append.c</a>, <a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1678&getkey=" target="_blank" rel="noopener">append.cc</a>,     </p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;
class Square&#123;
public:
    int a;
    Square()&#123;&#125;
    Square(int aa):a(aa)&#123;cout &lt;&lt; &quot;Construct Square (&quot; &lt;&lt; a &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    int length()&#123;return a;&#125;
    int perimeter()&#123;return 4*a;&#125;
    int area()&#123;return a*a;&#125;
&#125;;
class Rectangle:public Square&#123;
public:
    int b;
    Rectangle()&#123;&#125;
    Rectangle(int aa,int bb):Square(aa),b(bb)&#123;cout &lt;&lt; &quot;Construct Rectangle (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    int length()&#123;return a;&#125;
    int width()&#123;return b;&#125;
    int perimeter()&#123;return 2*(a+b);&#125;
    int area()&#123;return a*b;&#125;
&#125;;
class Cuboid:public Rectangle&#123;
public:
    int c;
    Cuboid()&#123;&#125;
    Cuboid(int aa,int bb,int cc):Rectangle(aa,bb),c(cc)&#123;cout &lt;&lt; &quot;Construct Cuboid (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;
    int length()&#123;return a;&#125;
    int width()&#123;return b;&#125;
    int height()&#123;return c;&#125;
    int perimeter()&#123;return 4*(a+b+c);&#125;
    int area()&#123;return 2*(a*b+a*c+b*c);&#125;
    int volume()&#123;return a*b*c;&#125;
&#125;;
////////////////////////
int main()
&#123;
    int cases, l, w, h;
    cin &gt;&gt; cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        cin &gt;&gt; l;
        Square squa(l);
        cout &lt;&lt; &quot;A Square length &quot; &lt;&lt; squa.length() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Perimeter &quot; &lt;&lt; squa.perimeter() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Area &quot; &lt;&lt; squa.area() &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;=========================&quot; &lt;&lt; endl;

    cin &gt;&gt; cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        cin &gt;&gt; l &gt;&gt; w;
        Rectangle rect(l, w);
        cout &lt;&lt; &quot;A Rectangle length &quot; &lt;&lt; rect.length() &lt;&lt; &quot;, width &quot; &lt;&lt; rect.width() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Perimeter &quot; &lt;&lt; rect.perimeter() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Area &quot; &lt;&lt; rect.area() &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;=========================&quot; &lt;&lt; endl;

    cin &gt;&gt; cases;
    for(int i = 1; i &lt;= cases; ++i)
    &#123;
        cin &gt;&gt; l &gt;&gt; w &gt;&gt; h;
        Cuboid cubo(l, w, h);
        cout &lt;&lt; &quot;A Cuboid length &quot; &lt;&lt; cubo.length() &lt;&lt; &quot;, width &quot; &lt;&lt; cubo.width() &lt;&lt; &quot;, height &quot; &lt;&lt; cubo.height() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Perimeter &quot; &lt;&lt; cubo.perimeter() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Area &quot; &lt;&lt; cubo.area() &lt;&lt; &quot;, &quot;;
        cout &lt;&lt; &quot;Volume &quot; &lt;&lt; cubo.volume() &lt;&lt; endl;
    &#125;

&#125;
</code></pre>
<h3 id="42-字符串类（I）"><a href="#42-字符串类（I）" class="headerlink" title="42.字符串类（I）*"></a>42.字符串类（I）*</h3><blockquote>
<h2 id="Description-41"><a href="#Description-41" class="headerlink" title="Description"></a>Description</h2><p>封装一个字符串类，用于存储字符串和处理的相关功能，支持以下操作：</p>
<p>\1. STR::STR()构造方法：创建一个空的字符串对象。</p>
<p>\2. STR::STR(const char *)构造方法：创建一个字符串对象，串的内容由参数给出。</p>
<p>\3. STR::length()方法：返回字符串的长度。</p>
<p>\4. STR::putline()方法：输出串的内容，并换行。</p>
<p>-—————————————————————————-</p>
<p>你设计一个字符串类STR，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<p>-—————————————————————————-</p>
<p>Invalid Word（禁用单词）错误：“string”、“vector”等被禁用。</p>
<h2 id="Input-41"><a href="#Input-41" class="headerlink" title="Input"></a>Input</h2><p>输入有若干行，每行一个字符串。</p>
<h2 id="Output-41"><a href="#Output-41" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应输出一行，包含两部分内容，首先是一个整数，表示输入串的长度，然后是输入的字符串，两者用一个空格分开。格式见sample。</p>
<h2 id="Sample-Input-41"><a href="#Sample-Input-41" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>A123456789</p>
<h2 id="Sample-Output-41"><a href="#Sample-Output-41" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0 12 Hello World!1 A9 123456789</p>
<h2 id="HINT-41"><a href="#HINT-41" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-41"><a href="#Append-Code-41" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1578&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;
int len(char * s)
&#123;
    int i = 0; int len_ = 0;
    while(s[i] != &#39;\0&#39; ) &#123; len_++; i++; &#125;
    return len_;
&#125;
void strcpy_(char *s, char *t)
&#123;
    int i  = 0;
    while(t[i] != &#39;\0&#39;) &#123; s[i] = t[i]; i++; &#125;
    s[i] = &#39;\0&#39;;
&#125;
class STR
&#123;
public:
    int length() const &#123; return len(stl); &#125;
    void putline() const &#123;  cout &lt;&lt; stl &lt;&lt; endl; &#125;
public:
    STR(char *s = NULL )
    &#123;
        if(s == NULL)
        &#123;
            stl = new char[1];
            stl[0] = &#39;\0&#39;;
        &#125;
        else
        &#123;
            stl = new char[len(s) + 1];
            strcpy_(stl,s);
        &#125;
    &#125;
private:
    char *stl;
&#125;;
int main()
&#123;
    STR e;
    STR h(&quot;Hello World!&quot;);
    char s[100001];
    cout &lt;&lt; e.length() &lt;&lt; &quot; &quot;;
    e.putline();
    cout &lt;&lt; h.length() &lt;&lt; &quot; &quot;;
    h.putline();
    while(gets(s) != NULL)
    &#123;
        STR str(s);
        cout &lt;&lt; str.length() &lt;&lt; &quot; &quot;;
        str.putline();
    &#125;
&#125;</code></pre>
<h3 id="43-字符串类（II）"><a href="#43-字符串类（II）" class="headerlink" title="43.字符串类（II）"></a>43.字符串类（II）</h3><blockquote>
<h2 id="Description-42"><a href="#Description-42" class="headerlink" title="Description"></a>Description</h2><p>封装一个字符串类，用于存储字符串和处理的相关功能，支持以下操作：</p>
<p>\1. STR::STR()构造方法：创建一个空的字符串对象。</p>
<p>\2. STR::STR(const char *)构造方法：创建一个字符串对象，串的内容由参数给出。</p>
<p>\3. STR::length()方法：返回字符串的长度。</p>
<p>\4. STR::putline()方法：输出串的内容，并换行。</p>
<p>\5. 运算符“+”和“+=”，表示两个字符串的连接运算，规则为：</p>
<p>   c = a + b 表示串c中的字符是a和b的连接：“a+b”的结果是一个新的字符串，串a和串b的内容不变。</p>
<p>   a += b    表示串a中的字符是a和b的连接：串b中的内容不变</p>
<p>-—————————————————————————-</p>
<p>你设计一个字符串类STR，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<p>-—————————————————————————-</p>
<p>Invalid Word（禁用单词）错误：“string”、“vector”等被禁用。</p>
<h2 id="Input-42"><a href="#Input-42" class="headerlink" title="Input"></a>Input</h2><p>输入有若干行，每行一个字符串。</p>
<h2 id="Output-42"><a href="#Output-42" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据对应输出一行，包含两部分内容，首先是一个整数，表示输入串的长度，然后是输入的字符串，两者用一个空格分开。格式见sample。</p>
<h2 id="Sample-Input-42"><a href="#Sample-Input-42" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>A123456789</p>
<h2 id="Sample-Output-42"><a href="#Sample-Output-42" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>12 Hello World!0 12 Hello World!12 Hello World!12 Hello World!10 A1234567891 A9 12345678910 123456789A1 A</p>
<h2 id="HINT-42"><a href="#HINT-42" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-42"><a href="#Append-Code-42" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1579&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code></code></pre>
<h3 id="44-数组类（I）"><a href="#44-数组类（I）" class="headerlink" title="44.数组类（I）"></a>44.数组类（I）</h3><blockquote>
<h2 id="Description-43"><a href="#Description-43" class="headerlink" title="Description"></a>Description</h2><p>封装一个整型数组类，用于存储整数和处理的相关功能，支持以下操作：</p>
<p>\1. Array::Array()无参构造方法：创建一个空数组对象。</p>
<p>\2. Array::size()方法：返回Array对象中元素个数。</p>
<p>\3. Array::get(int n)方法：按格式从输入读取n元素。</p>
<p>\4. 下标运算符：返回下标所指的元素。</p>
<p>-—————————————————————————-</p>
<p>你设计一个数组类Array，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数</p>
<h2 id="Input-43"><a href="#Input-43" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的每行以一个整数k开头，表示后面有k个整数。</p>
<h2 id="Output-43"><a href="#Output-43" class="headerlink" title="Output"></a>Output</h2><p>把输入的数组，输出出来。每行数据对应一个输出。格式见sample。</p>
<h2 id="Sample-Input-43"><a href="#Sample-Input-43" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>42 10 201 003 1 2 3</p>
<h2 id="Sample-Output-43"><a href="#Sample-Output-43" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>10 2001 2 3</p>
<h2 id="HINT-43"><a href="#HINT-43" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-43"><a href="#Append-Code-43" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1572&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
class Array&#123;
public:
    vector&lt;int&gt; a;
    int l;
    Array():l(0)&#123;&#125;
    int size()&#123;return l;&#125;
    void get(int n)&#123;
        l=n;a.resize(n);
        for(int i=0;i&lt;n;i++)&#123;
            int x;
            cin &gt;&gt; x;
            a[i]=x;
        &#125;
    &#125;
    int operator[](int x)&#123;return a[x];&#125;
&#125;;
//////////////////////////////////////////
int main()
&#123;
    int cases;
    Array arr;
    cin &gt;&gt; cases;
    for(int ca = 1; ca &lt;= cases; ca++)
    &#123;
        int len;
        cin &gt;&gt; len;
        arr.get(len);
        for(int i = 0; i &lt; arr.size(); i++)
            if(i + 1 == arr.size())
                cout &lt;&lt; arr[i];
            else
                cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h3 id="45-数组类（II）"><a href="#45-数组类（II）" class="headerlink" title="45.数组类（II）"></a>45.数组类（II）</h3><blockquote>
<h2 id="Description-44"><a href="#Description-44" class="headerlink" title="Description"></a>Description</h2><p>封装一个模板数组类，用于存储数组和处理的相关功能，支持以下操作：</p>
<p>\1. Array::Array(int l)构造方法：创建一个长度为l的组对象。</p>
<p>\2. Array::size()方法：返回Array对象中元素个数。</p>
<p>\3. Array::put(int n)方法：按从大到小的顺序输出前n大元素，若数组长度小于n则从大到小输出全部元素。</p>
<p>\4. 下标运算符：返回下标所指的元素。</p>
<p>-—————————————————————————-</p>
<p>你设计一个模板数组类Array，使得main()函数能够正确运行。</p>
<p>函数调用格式见append.cc。</p>
<p>append.cc中已给出main()函数。</p>
<h2 id="Input-44"><a href="#Input-44" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示有n组测试数据。</p>
<p>后面的每行以一个整数k开头，表示后面有k个同类型的数组元素。</p>
<p>数组元素有以下三种类型：整数、浮点数和字符，并且按固定的次序间隔出现。</p>
<h2 id="Output-44"><a href="#Output-44" class="headerlink" title="Output"></a>Output</h2><p>把输入的数组，按值从大到小输出前10个元素，若输入不足10个则全部输出。每行数据对应一个输出。格式见sample。</p>
<h2 id="Sample-Input-44"><a href="#Sample-Input-44" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>310 1 2 3 4 5 6 7 8 9 05 1.1 2.2 3.3 4.4 5.520 ABCDEGHIJMNPRSTUVWXY</p>
<h2 id="Sample-Output-44"><a href="#Sample-Output-44" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>9 8 7 6 5 4 3 2 1 05.5 4.4 3.3 2.2 1.1Y X W V U T S R P N</p>
<h2 id="HINT-44"><a href="#HINT-44" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-44"><a href="#Append-Code-44" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1573&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;  
using namespace std;  
template&lt;class T&gt;  
class Array  
&#123;  
private:  
    T *sss;  
    int si;  
public:  
    Array(int l):si(l)&#123;sss=new T[si];&#125;  
    ~Array()&#123;if (sss!=NULL)delete []sss;&#125;  
    int size()&#123;return si;&#125;  
    void put(int n)  
    &#123;  
        int i,j;  
        for(i=0;i&lt;si-1;i++)//挨着和每个比，最后一个不用了  
        &#123;  
            for(j=i+1;j&lt;si;j++)//从下一个开始，到最后  
            &#123;  
                if(sss[i]&lt;sss[j])  
                &#123;  
                    T t=sss[i];  
                    sss[i]=sss[j];  
                    sss[j]=t;  
                &#125;  
            &#125;  
        &#125;  
        if(n&gt;si)  
        n=si;  
            cout&lt;&lt;sss[0];  
        for(int i=1;i&lt;n;i++)  
            cout&lt;&lt;&quot; &quot;&lt;&lt;sss[i];  
        cout&lt;&lt;endl;  
    &#125;  
    T&amp; operator[](int n)//少个引用，我去  
    &#123;  
        return sss[n];  
    &#125;  
&#125;; 
//////////////////////////////////////////
int main()
&#123;
    int cases, len;
    cin &gt;&gt; cases;
    for(int ca = 1; ca &lt;= cases; ca++)
    &#123;
        cin &gt;&gt; len;
        if(ca % 3 == 0)
        &#123;
            Array&lt;char&gt; chr_arr(len);
            for(int i = 0; i &lt; chr_arr.size(); i++)
                cin &gt;&gt; chr_arr[i];
            chr_arr.put(10);
        &#125;
        if(ca % 3 == 1)
        &#123;
            Array&lt;int&gt; int_arr(len);
            for(int i = 0; i &lt; int_arr.size(); i++)
                cin &gt;&gt; int_arr[i];
            int_arr.put(10);
        &#125;
        if(ca % 3 == 2)
        &#123;
            Array&lt;double&gt; dbl_arr(len);
            for(int i = 0; i &lt; dbl_arr.size(); i++)
                cin &gt;&gt; dbl_arr[i];
            dbl_arr.put(10);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="46-Problem-E-农夫果园"><a href="#46-Problem-E-农夫果园" class="headerlink" title="46.Problem E: 农夫果园"></a>46.Problem E: 农夫果园</h3><blockquote>
<h2 id="Description-45"><a href="#Description-45" class="headerlink" title="Description"></a>Description</h2><p>秋天到了，果园里的水果成熟了，商贩们来收水果了，农夫们都希望自己的水果能卖个好价钱。</p>
<p>现在果园里有三种水果正在销售，苹果（Apple）、香蕉（Banana）、梨（Pear）。每次销售都会记录下水果的种类、单价和总量，input()函数可以读取每条销售记录的单价和总量，total()函数可以计算出这次销售的总价。</p>
<p>但是，销售员在记录时忙中出错，各中水果的单价和总量的单位没有统一。单价是每公斤的价格，而水果是按箱记录的。其中，苹果一箱按30公斤计算，香蕉一箱按25公斤计算，梨一箱按20公斤计算。每种水果每次销售的总价是“单价<em>总量</em>每箱公斤数”。</p>
<p>现在，你来设计一个程序帮忙计算果园卖出水果的总价。由于total()函数对每种水果的计算方式都不一样，因此使用多态来实现。</p>
<p>-—————————————————————————-</p>
<p>你设计并实现这个水果类的派生体系，使得main()函数能够运行并得到正确的输出。调用格式见append.cc</p>
<h2 id="Input-45"><a href="#Input-45" class="headerlink" title="Input"></a>Input</h2><p>输入的第一个整数n，表示后面有n条水果收购的记录。每条记录分为3部分，水果种类、单价和总量。</p>
<h2 id="Output-45"><a href="#Output-45" class="headerlink" title="Output"></a>Output</h2><p>输出为一行，表示整个果园卖出水果的总价。</p>
<h2 id="Sample-Input-45"><a href="#Sample-Input-45" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5Apple 4.2 100Banana 8.8 50Apple 4.5 200Banana 7.8 100Pear 3.7 100</p>
<h2 id="Sample-Output-45"><a href="#Sample-Output-45" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Total Price : 77500</p>
<h2 id="HINT-45"><a href="#HINT-45" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-45"><a href="#Append-Code-45" class="headerlink" title="Append Code"></a>Append Code</h2><p><a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=0&pid=1670&getkey=" target="_blank" rel="noopener">append.c</a>, <a href="http://192.168.119.211/JudgeOnline/append_detail.php?lang=1&pid=1670&getkey=" target="_blank" rel="noopener">append.cc</a>,</p>
</blockquote>
<pre><code>#include&lt;iostream&gt;
using namespace std;
class Fruit&#123;
public:
    string name;
    double per;
    int n;
    Fruit()&#123;&#125;
    Fruit(string n):name(n)&#123;&#125;
    void input()&#123;cin&gt;&gt;per&gt;&gt;n;&#125;
    virtual double total()=0;
&#125;;
class Apple:public Fruit&#123;
public:
    string name;
    ///double per;
    ///int n;
    Apple():name(&quot;Apple&quot;)&#123;&#125;
    double total()&#123;return per*n*30;&#125;
&#125;;
class Banana:public Fruit&#123;
public:
    string name;
    ///double per;
    ///int n;
    Banana():name(&quot;Banana&quot;)&#123;&#125;
    double total()&#123;return per*n*25;&#125;
&#125;;
class Pear:public Fruit&#123;
public:
    string name;
    ///double per;
    ///int n;
    Pear():name(&quot;Pear&quot;)&#123;&#125;
    double total()&#123;return per*n*20;&#125;
&#125;;
int main()
&#123;
    Fruit* fruit;
    string fruit_name;
    double sum = 0.0;
    int cases;
    cin &gt;&gt; cases;
    for(int i = 1; i &lt;= cases; i++)
    &#123;
        cin &gt;&gt; fruit_name;
        if(fruit_name == &quot;Apple&quot;)
            fruit = new Apple();
        if(fruit_name == &quot;Banana&quot;)
            fruit = new Banana();
        if(fruit_name == &quot;Pear&quot;)
            fruit = new Pear();
        fruit-&gt;input();
        sum += fruit-&gt;total();
        delete fruit;
    &#125;
    cout &lt;&lt; &quot;Total Price : &quot; &lt;&lt; sum &lt;&lt; endl;

     return 0;
&#125;</code></pre>
<h3 id="47-一元二次方程类"><a href="#47-一元二次方程类" class="headerlink" title="47.一元二次方程类"></a>47.一元二次方程类</h3><blockquote>
<h2 id="Description-46"><a href="#Description-46" class="headerlink" title="Description"></a>Description</h2><p>定义一个表示一元二次方程的类Equation，该类至少具有以下3个数据成员：a、b和c，用于表示方程“a<em>x</em>x + b*x +c = 0”。同时，该类还至少具有以下两个成员函数：</p>
<p>\1. void solve()：用于求方程的根。</p>
<p>\2. void printRoot()：用于输出方程的根。</p>
<p>设定：</p>
<p>\1. 所有输入的a、b、c所生成的方程必定有个2个不同的实根。</p>
<p>\2. 输出的两个根按照从大到小的顺序输出，两个根之间用一个空格隔开，而且每个根必须且仅能保留2位小数，即使小数部分为0。</p>
<p>\3. 请根据样例和给出的main()函数定义相应的构造函数。</p>
<h2 id="Input-46"><a href="#Input-46" class="headerlink" title="Input"></a>Input</h2><p>输入有若干行，每行有3个实数，分别为方程“a<em>x</em>x + b*x + c = 0”中的系数a、b、c。</p>
<h2 id="Output-46"><a href="#Output-46" class="headerlink" title="Output"></a>Output</h2><p>按照题目要求中的设定条件2输出方程的根。</p>
<h2 id="Sample-Input-46"><a href="#Sample-Input-46" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1 3 2</p>
<h2 id="Sample-Output-46"><a href="#Sample-Output-46" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>-1.00 -2.00</p>
<h2 id="HINT-46"><a href="#HINT-46" class="headerlink" title="HINT"></a>HINT</h2><p>可以使用fixed和setprecision()来实现输出固定小数位数的数值。</p>
<h2 id="Append-Code-46"><a href="#Append-Code-46" class="headerlink" title="Append Code"></a>Append Code</h2><p>[append.cc](./Problem B_ 一元二次方程类_files/Source Code.html),</p>
</blockquote>
<pre><code>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;math.h&gt;
using namespace std;
class Equation
&#123;
private :
    double a,b,c,x1,x2;
   public:
     Equation(double x,double y,double z)
     &#123;
         a = x;b = y; c = z;
     &#125;
     void solve ()
     &#123;

         x1 = (-b+sqrt(b*b-4*a*c))/(2*a);
         x2 = (-b-sqrt(b*b-4*a*c))/(2*a);
     &#125;
    void printRoot()
    &#123;
       //cout.precision(3);
       cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl;
    &#125;
&#125;;</code></pre>
<blockquote>
<pre><code>setiosflags(ios::fixed)是用定点方式表示实数。 
使用setprecision(n)可控制输出流显示浮点数的数字个数。C++默认的流输出数值有效位是6。
如果setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。</code></pre>
</blockquote>
<h3 id="48-字符类的封装"><a href="#48-字符类的封装" class="headerlink" title="48.字符类的封装"></a>48.字符类的封装</h3><blockquote>
<h2 id="Description-47"><a href="#Description-47" class="headerlink" title="Description"></a>Description</h2><p>先来个简单习题，练练手吧！现在需要你来编写一个Character类，将char这一基本数据类型进行封装。该类中需要有如下成员函数：</p>
<p>\1. 无参构造函数。</p>
<p>\2. 构造函数Character(char)：用参数初始化数据成员。</p>
<p>\3. void setCharacter(char)：重新设置字符值。</p>
<p>\4. int getAsciiCode()：返回字符的ASII码。</p>
<p>\5. char getCharacter()：返回字符值。</p>
<p>\6. 析构函数。</p>
<h2 id="Input-47"><a href="#Input-47" class="headerlink" title="Input"></a>Input</h2><p>输入只有1行，包含一个合法的、可打印的字符。</p>
<h2 id="Output-47"><a href="#Output-47" class="headerlink" title="Output"></a>Output</h2><p>输出有好多行，请参考样例来编写相应的函数。</p>
<h2 id="Sample-Input-47"><a href="#Sample-Input-47" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>c</p>
<h2 id="Sample-Output-47"><a href="#Sample-Output-47" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Default constructor is called!Character a is created!ch1 is c and its ASCII code is 99.ch2 is a and its ASCII code is 97.Character a is erased!Character c is erased!</p>
<h2 id="HINT-47"><a href="#HINT-47" class="headerlink" title="HINT"></a>HINT</h2><h2 id="Append-Code-47"><a href="#Append-Code-47" class="headerlink" title="Append Code"></a>Append Code</h2><p>[append.cc](./Problem D_ 字符类的封装_files/Source Code.html),</p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
class Character&#123;
public:
    char c;
    Character()&#123;cout &lt;&lt; &quot;Default constructor is called!&quot; &lt;&lt; endl;&#125;
    Character(char cc):c(cc)&#123;cout &lt;&lt; &quot;Character &quot; &lt;&lt; c &lt;&lt; &quot; is created!&quot; &lt;&lt; endl;&#125;
    void setCharacter(char cc)&#123;c=cc;&#125;
    int getAsciiCode()&#123;return (int)c;&#125;
    char getCharacter()&#123;return c;&#125;
    ~Character()&#123;cout &lt;&lt; &quot;Character &quot; &lt;&lt; c &lt;&lt; &quot; is erased!&quot; &lt;&lt; endl;&#125;
&#125;;
///////////////////
int main()
&#123;
    char ch;
    Character ch1, ch2(&#39;a&#39;);
    cin&gt;&gt;ch;
    ch1.setCharacter(ch);
    cout&lt;&lt;&quot;ch1 is &quot;&lt;&lt;ch1.getCharacter()&lt;&lt;&quot; and its ASCII code is &quot;&lt;&lt;ch1.getAsciiCode()&lt;&lt;&quot;.&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;ch2 is &quot;&lt;&lt;ch2.getCharacter()&lt;&lt;&quot; and its ASCII code is &quot;&lt;&lt;ch2.getAsciiCode()&lt;&lt;&quot;.&quot;&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>33/42</p>
</blockquote>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LANVNAL</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://lanvnal.com/2017/05/04/c-ti-mu-oj/">https://lanvnal.com/2017/05/04/c-ti-mu-oj/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LANVNAL</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/other/">
                                    <span class="chip bg-color">other</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2017/05/18/binwalk-chang-yong-ming-ling/">
                    <div class="card-image">
                        
                        
                        <img src="https://lanvnal-blog.oss-cn-qingdao.aliyuncs.com/blog-theme-pic/coverimgs/2.jpg" class="responsive-img" alt="binwalk常用命令">
                        
                        <span class="card-title">binwalk常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2017-05-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/note/" class="post-category">
                                    note
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/note/">
                        <span class="chip bg-color">note</span>
                    </a>
                    
                    <a href="/tags/binwalk/">
                        <span class="chip bg-color">binwalk</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2017/05/02/iscc-writeup/">
                    <div class="card-image">
                        
                        
                        <img src="https://lanvnal-blog.oss-cn-qingdao.aliyuncs.com/blog-theme-pic/coverimgs/1.jpg" class="responsive-img" alt="ISCC-WriteUp">
                        
                        <span class="card-title">ISCC-WriteUp</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2017-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CTF/" class="post-category">
                                    CTF
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/WriteUp/">
                        <span class="chip bg-color">WriteUp</span>
                    </a>
                    
                    <a href="/tags/CTF/">
                        <span class="chip bg-color">CTF</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2017</span>
            <a href="/about" target="_blank">LANVNAL</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">124.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2017";
                    var startMonth = "3";
                    var startDate = "15";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LANVNAL" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:lanvnal@foxmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
